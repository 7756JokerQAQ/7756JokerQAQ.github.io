<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试题1 | JokerQAQ的博客</title><meta name="keywords" content="面试"><meta name="author" content="LiYiChen"><meta name="copyright" content="LiYiChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一些常提问面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题1">
<meta property="og:url" content="https://7756jokerqaq.github.io/2023/02/27/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/mainshi/index.html">
<meta property="og:site_name" content="JokerQAQ的博客">
<meta property="og:description" content="一些常提问面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png">
<meta property="article:published_time" content="2023-02-26T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-29T01:05:08.949Z">
<meta property="article:author" content="LiYiChen">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/7756JokerQAQ/picodemoo/main/img/WebImg.png"><link rel="canonical" href="https://7756jokerqaq.github.io/2023/02/27/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/mainshi/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: LiYiChen","link":"链接: ","source":"来源: JokerQAQ的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-29 09:05:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/duotone.css"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/wallhaven-4y6170_1920x1080.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JokerQAQ的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T01:05:08.949Z" title="更新于 2023-03-29 09:05:08">2023-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面试题性的总结与回答"><a href="#面试题性的总结与回答" class="headerlink" title="面试题性的总结与回答"></a>面试题性的总结与回答</h1><p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/2019061210551736.png" alt="img"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/image-20230224093155759.png" alt="image-20230224093155759"></p>
<h3 id="1-Java-常用的集合？"><a href="#1-Java-常用的集合？" class="headerlink" title="1.  Java 常用的集合？"></a>1.  Java 常用的集合？</h3><ul>
<li>Collection接口：Set、List</li>
<li>Map的接口：map、TreeMap、HashMap、LinkedHashMap、HashTable、ConcurrentHashMap</li>
</ul>
<h3 id="2-集合之间有什么区别？"><a href="#2-集合之间有什么区别？" class="headerlink" title="2.   集合之间有什么区别？"></a>2.   集合之间有什么区别？</h3><p>List、set、map是三个接口，List和set继承自collection接口，Map也属于集合系统，与collection不同。</p>
<p>Set不允许元素重复，HashSet和TreeSet是两个主要的实现类，Set只能通过游标来取值，并且值是不能重复的</p>
<p><strong>AbstractList集合：</strong></p>
<ul>
<li>list列表是个有序集合、它的直接实现类是Arraylist(直接实现类)，它是线程不同步的，主要以数组的方式建立了一个列表,适合进行遍历和快速查找某一个元素、修改，不适用于删除和在任意位置增加一个元素。</li>
<li>LinkedList(间接实现类)它也是线程不同步的列表、但是他是通过列表来实现的、该方法主要用于对元素的增加删除但不适用于遍历。</li>
<li>ArrayList线程不同步：实现一个数组，他是以数组的方式实现的List，允许随机存取</li>
<li>Vector（直接实现类）他是线程同步的，它实现了一个可增长的对象数组，它也可以实用整数的数组访问元素。</li>
</ul>
<p><strong>AbstractSet集合</strong>：</p>
<ul>
<li>Set集合的特点是元素无序的、不允许重复的元素，有且仅有一个空的元素。只是简单的将对象加入到集合中</li>
<li>HashSet（直接实现类）它是线程不同步的、他不保证集合的迭代顺序、他不能保证顺序会随着时间不变</li>
<li>TreeSet（直接实现类）是线程不同步的，他底层是基于TreeMap实现的,底层结构是个二叉树，它可以给Set集合中的元素进行指定的方式排序保证元素的唯一性的方式。</li>
<li>LinkedHashSet(间接实现类) 哈希表和链表的实现集合接口，具有可预测的迭代顺序,这个链表定义了迭代顺序、这是元素插入到集合的顺序（插入顺序）</li>
</ul>
<p>Set与List的区别：</p>
<p>List基本上都是以Array为基础（LinkedList是以链表存储）但是Set是以HashMap</p>
<p><strong>AbstractMap集合：</strong></p>
<p>map是一种键值对集合，键值不能重复值可以重复，Map没有继承于Collection接口从map集合中检索元素市，根据键得到值，对map集合遍历时先得键的set集合，对set集合进行遍历得到相应的值。map的遍历主要时以KeySet（）因为Set具备迭代器可以迭代取出所有的键，再根据get方法获取每一个键值对应的值，KeySet（）迭代后只能通过get（）取Key。entrySet（）它包含映射关系的Set视图（一个关系就是一个键值对）就是把Key—value作为一个整体，一对一对的存放在Set集合中，Map.Entry表示映射关系可以通过e.getKey(),e.getValue（）两种方法取得key和value，返回的是Entry接口。</p>
<ul>
<li>HashMap直接（实现类）优点访问速度快，无顺序的保存元素。</li>
<li>HashTable 不允许有null，HashMap允许</li>
<li>HashTable有一个Enumeration遍历，HashMap是Iterator迭代器遍历</li>
<li>HashTable有一个contains()方法功能和containsValue（）功能一样；</li>
<li>HashTable中的hash数组默认的默认大小11增长方式是old*2+1;HashMap中hash数组默认大小是16一定是2的指数</li>
<li>哈希值的使用不同，hashtable直接使用对象的hashcode而hashmap重新计算hash值</li>
</ul>
<h3 id="3-集合之间有什么转换关系？"><a href="#3-集合之间有什么转换关系？" class="headerlink" title="3.集合之间有什么转换关系？"></a>3.集合之间有什么转换关系？</h3><p>数组转集合使用asList（）方法需要注意：</p>
<ul>
<li>如果传入的是一个数组一定得是引用类型才能将其转换为List集合</li>
<li>无法对集合进行修改操作，否则会报错</li>
<li>仅仅局限于一维数组系列</li>
</ul>
<p><strong>集合转数组</strong>： 必须是包装类型的数组</p>
<p>JDK8可以用stream API可以很容易解决</p>
<p><strong>原生数组、包装类型的数组互转：</strong> <strong>包装类数组与list集合互转</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int&lt;----&gt;Integer&lt;----&gt;List</span><br><span class="hljs-comment">//原生数组转包装类型的数组：</span><br><span class="hljs-type">int</span>[] nums = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>};<br>Integer[]boxdNums=Arrays.stream(nums).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">//包装类型转换为原生类型的数组</span><br><span class="hljs-type">int</span>[] arrs = Arrays.stream(boxdNums).mapToInt(Integer::intValue).toArray();<br><span class="hljs-comment">//包装类数组转为List/ArraysList：Arrays.asList</span><br>List&lt;Integer&gt;listInteget=Arrays.asList(boxdNums);<br><span class="hljs-comment">//List/ArrayList转包装类数组    .toArray(new Integer[])</span><br>Integer[] arrayInter2 = listInter.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[listInter.size()]);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* String&lt;-------&gt;List</span><br><span class="hljs-comment">*/</span><br> 	    List&lt;String&gt; listStringStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        listStringStr.add(<span class="hljs-string">"str1"</span>);<br>        listStringStr.add(<span class="hljs-string">"str2"</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listStringStr.size();<br>        String[] arr = (String[]) listStringStr.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[size]);<span class="hljs-comment">//使用了第二种接口，返回值和参数均为结果</span><br>        List&lt;String&gt; strings = Arrays.asList(arr);<br><span class="hljs-comment">//集合转数组 toArray()</span><br><span class="hljs-comment">//使用toArray()是要注意，有参方法和无参方法，一般都选择使用有参方法， </span><br><span class="hljs-comment">//无参方法返回的是一个Object类型数组，</span><br><span class="hljs-comment">// 即使集合携带泛型。所以用如果使用无参方法会面临数据类型转换，相对更加麻烦。</span><br>List&lt;Integer&gt; listIntegerStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        listIntegerStr.add(<span class="hljs-number">1</span>);<br>        listIntegerStr.add(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 方式一</span><br>        Integer[] arrays = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[listIntegerStr.size()];<br>        listIntegerStr.toArray(arrays);<br>        <span class="hljs-comment">// 方式二</span><br>        Integer[] arrays_00 = listIntegerStr.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//方式三 不推荐</span><br>       Object[] objects = listIntegerStr.toArray();<br><br></code></pre></td></tr></tbody></table></figure>
<p><strong>比较器是什么？方法</strong></p>
<p>Comparable和Comparator接口</p>
<ul>
<li>对于Comparable 接口来说就有一个CompareTo（）方法只有一个参数，返回值为int</li>
<li>对于Comparator接口称为比较器包含一个compare（）方法返回值与CompareTo（）一样不同的是Comparator接口一般不会被集合元素类所实现，而是单独的使用或者在匿名内部类中使用，比较器不仅用于比较大小还用于排序只需要将Comparator传递给sort方法。</li>
</ul>
<p><strong>基本数据类型和引用数据类型的区别</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/a610ff04860149ccbc3e55732f042526.png" alt="img"></p>
<p>每一个基本数据类型都会对应一个包装类型</p>
<p><strong>装箱和拆箱</strong></p>
<p>装箱：把基本数据类型转换成对应的包装类型</p>
<p>拆箱：把包装类型转换为基本的数据类型</p>
<p>java是一个面向对象的语言，而基本数据类型不具备面向对象的特点。</p>
<p><strong>String、StringBuild和Stringbuffer的区别：</strong></p>
<ul>
<li>String是Immutable类的基本实现声明了final class 因为它的不可变性，拼接字符串是会出现很多无用的中间对象，如果频繁的操作对性能有些影响。</li>
<li>StringBuffer就是为了解决大量的字符串拼接产生的中间变量而提供的一个类，其中append方法和add方法，它的本质是个线程安全的可修改的字符串序列，牺牲了部分性能它的方法都加上了synchronized方法</li>
<li>StringBuilder是JDK1.5发布的 去掉了线程安全的部分减少了开销</li>
<li><p>Stringbuffer和StringBuilder都继承了Abstract StringBuilder 底层都是可以修改的char数组JDK9 以后是byte数组</p>
<p><strong>java 基本数据类型、包装类、字符串、数组之间的类型转换</strong></p>
</li>
</ul>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/8ff5f5752eb1446eac015180987cbbb3.png" alt="img"></p>
<p><strong>优雅的将List集合转为Set集合：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">list集合和set集合的区别</span><br><span class="hljs-comment">两者都集成了Collection</span><br><span class="hljs-comment">list是有顺序的所以它的值是可重复的</span><br><span class="hljs-comment">list的数据结构是线性结构所以他在遍历的时候特别快</span><br><span class="hljs-comment">set是无序的不能够插入重复的元素</span><br><span class="hljs-comment">Set的数据结构是哈希表所以在频繁添加或移除元素的业务场景下特别有优势</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//xxx.stream().collect(Collectors.toSet());</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lisToSetTest</span><span class="hljs-params">()</span> {<br>		<br>		List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>		list.add(<span class="hljs-string">"A"</span>);<br>		list.add(<span class="hljs-string">"A"</span>);<br>		list.add(<span class="hljs-string">"B"</span>);<br>		Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>		set = list.stream().collect(Collectors.toSet());<br>		System.out.println(set);<br>	}<br><span class="hljs-comment">//第二种方法</span><br>Set&lt;Integer&gt; setFromList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(list);<br><br><span class="hljs-comment">//set转为list集合</span><br>List list=Stream.of(set.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>])).collect(Collectors.toList());<br>List&lt;Integer&gt; listFromSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(set);<br>List&lt;Integer&gt; hashSetList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(hashSet);<br>List&lt;Integer&gt; linkedHashSetList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(linkedHashSet);<br></code></pre></td></tr></tbody></table></figure>
<p> <strong>List转为Map</strong></p>
<p>先把集合转为流，在调用流的归并操作collect方法。collect方法的参数通过调用Collectors.toMap（）方法获取该方法的两个参数为两个Function类型的对象分别代表根据List中生成的Map的key和value策略</p>
<h3 id="4-Stream流的方法？"><a href="#4-Stream流的方法？" class="headerlink" title="4. Stream流的方法？"></a>4. Stream流的方法？</h3><p>特点：不是数据结构，不会保存数据。不会修改原来的数据源，它的将操作后的数据保存到另一个对象中。惰性求值，流在中间处理过程中，只对操作进行记录，并不会立即执行</p>
<p><strong>分类</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/13170952_625693608975b29303.png" alt="img"></p>
<p>无状态：指元素的处理不受之前元素的影响；</p>
<p>有状态：指该操作只有拿到所有元素之后才能继续下去</p>
<p>非短路操作：指必须处理所有元素才能得到的最终结果</p>
<p>短路操作：遇到某些符合条件的元素就能得到最终的结果如A||B只要A为Treu则无需判断B的结果</p>
<p><strong>流的创建方法：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Stream&lt;String&gt; stream = list.stream(); <span class="hljs-comment">//获取一个顺序流</span><br>Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="hljs-comment">//获取一个并行流</span><br><span class="hljs-comment">//使用Arrays 中的stream()方法，将数组转成流</span><br>Integer[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];<br>Stream&lt;Integer&gt; stream = Arrays.stream(nums);<br></code></pre></td></tr></tbody></table></figure>
<p>Stream中的静态方法：of() 、iterator（）、generate（）</p>
<ul>
<li>使用BufferedReader.line（）方法将每行内容转换为流</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"F:\\test_stream.txt"</span>));<br>Stream&lt;String&gt; lineStream = reader.lines();<br>lineStream.forEach(System.out::println);<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>使用Pattern.splitAsStream（）方法将字符串分割成流</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">","</span>);<br>Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="hljs-string">"a,b,c,d"</span>);<br>stringStream.forEach(System.out::println);<br></code></pre></td></tr></tbody></table></figure>
<p><strong>流的中间操作</strong></p>
<ul>
<li>filter（）：过滤流中的某些元素</li>
<li>limit（）：获取n个元素</li>
<li>skip（）：跳过n个元素配合limit可以实现分页</li>
<li>distinct：通过流中的元素hashCode（）和equls（）去除重复元素</li>
</ul>
<p><strong>映射</strong></p>
<ul>
<li>map：接收一个函数作为参数，该函数可以被应用到每个元素上，并将其映射成一个新的元素</li>
<li>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"a,b,c"</span>, <span class="hljs-string">"1,2,3"</span>);<br> <br><span class="hljs-comment">//将每个元素转成一个新的且不带逗号的元素</span><br>Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="hljs-string">","</span>, <span class="hljs-string">""</span>));<br>s1.forEach(System.out::println); <span class="hljs-comment">// abc  123</span><br><br>Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; {<br>    <span class="hljs-comment">//将每个元素转换成一个stream</span><br>    String[] split = s.split(<span class="hljs-string">","</span>);<br>    Stream&lt;String&gt; s2 = Arrays.stream(split);<br>    <span class="hljs-keyword">return</span> s2;<br>});<br>s3.forEach(System.out::println); <span class="hljs-comment">// a b c 1 2 3</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>排序</strong></p>
<ul>
<li>sort（）：自然排序，流中元素需要实现Comparable接口</li>
<li>sorted（Comparator com）：定制排序，自定义Comparator排序器</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"aa"</span>, <span class="hljs-string">"ff"</span>, <span class="hljs-string">"dd"</span>);<br><span class="hljs-comment">//String 类自身已实现Compareable接口</span><br>list.stream().sorted().forEach(System.out::println);<span class="hljs-comment">// aa dd ff</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>{<br>     String a;<br>     <span class="hljs-type">int</span> b;<br> }<br>List&lt;Student&gt; studentList = Arrays.asList(s1, s2, s3, s4);<br><br><span class="hljs-comment">//自定义排序：先按姓名升序，姓名相同则按年龄升序</span><br>studentList.stream().sorted(<br>        (o1, o2) -&gt; {<br>            <span class="hljs-keyword">if</span> (o1.getName().equals(o2.getName())) {<br>                <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">return</span> o1.getName().compareTo(o2.getName());<br>            }<br>        }<br>).forEach(System.out::println);<br><br></code></pre></td></tr></tbody></table></figure>
<p>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值</p>
<p>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false</p>
<ul>
<li>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</li>
<li>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false</li>
<li>findFirst：返回流中第一个元素</li>
<li>findAny：返回流中的任意元素</li>
<li>count：返回流中元素的总个数</li>
<li><p>max：返回流中元素最大值</p>
</li>
<li><p>min：返回流中元素最小值</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br> <br><span class="hljs-type">boolean</span> <span class="hljs-variable">allMatch</span> <span class="hljs-operator">=</span> list.stream().allMatch(e -&gt; e &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">//false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">noneMatch</span> <span class="hljs-operator">=</span> list.stream().noneMatch(e -&gt; e &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">//true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">anyMatch</span> <span class="hljs-operator">=</span> list.stream().anyMatch(e -&gt; e &gt; <span class="hljs-number">4</span>);  <span class="hljs-comment">//true</span><br> <br><span class="hljs-type">Integer</span> <span class="hljs-variable">findFirst</span> <span class="hljs-operator">=</span> list.stream().findFirst().get(); <span class="hljs-comment">//1</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">findAny</span> <span class="hljs-operator">=</span> list.stream().findAny().get(); <span class="hljs-comment">//1</span><br> <br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream().count(); <span class="hljs-comment">//5</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> list.stream().max(Integer::compareTo).get(); <span class="hljs-comment">//5</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> list.stream().min(Integer::compareTo).get(); <span class="hljs-comment">//1</span><br><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>collect：接收一个Collector实例，将流中元素收集成另外一个数据结构。</li>
</ul>
<h3 id="5-多线程的理解"><a href="#5-多线程的理解" class="headerlink" title="5. 多线程的理解?"></a>5. 多线程的理解?</h3><p>线程是进程的执行单位、在程序中、线程是独立的、并发的执行流</p>
<p>线程的特点：</p>
<ol>
<li>每个线程都有自己的堆栈，程序计数器、局部变量、体现了线程的独立性</li>
<li>相同父进程下的所有线程共享进程独立的内存单元（eg：代码段、进程的共有数据），为此可以实现线程的相互通信(动态性)</li>
<li>多个线程之间可以并发进行、互不影响.（并发性）</li>
</ol>
<h3 id="6-什么时候用到多线程？"><a href="#6-什么时候用到多线程？" class="headerlink" title="6. 什么时候用到多线程？"></a>6. 什么时候用到多线程？</h3><ol>
<li>当需要同时执行多个任务的时候（高并发）</li>
<li>当需要在不影响其他部分的情况下执行大量的计算时候（后台处理大量的任务）</li>
<li>当需要并行执行多个网络操作时</li>
</ol>
<p>对于<strong>处理时间短的服务</strong>或者<strong>启动频率高</strong>的要用单线程，相反用多线程</p>
<h3 id="7-线程怎么用？"><a href="#7-线程怎么用？" class="headerlink" title="7.线程怎么用？"></a>7.线程怎么用？</h3><ol>
<li>创建一个线程类，继承Thread类或者实现Runnable接口，这个类就成为了一个线程类</li>
<li>重写run（）方法：在这个线程类中，重写run（）方法，该方法是线程执行的入口，定义线程执行操作</li>
<li>创建线程实例：创建线程实例并调用start（）方法启动线程</li>
<li>线程执行：线程启动后会自动调用run（）方法中的定义操作，执行线程</li>
<li>线程控制：在执行过程中可以使用线程控制方法如:sleep() 、yield（）、join（）等方法</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> extend Thread{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"MyThread running"</span>);<br>    }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> implments Runnable{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"MyRunnable running"</span>);<br>    }<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>(){<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> {<br>      <span class="hljs-comment">// 创建线程类实例</span><br>      <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>      <span class="hljs-comment">// 创建线程实例，并启动线程</span><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>      t1.start();<br>      t2.start();<br>   }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="8-run方法和start方法有什么区别"><a href="#8-run方法和start方法有什么区别" class="headerlink" title="8. run方法和start方法有什么区别?"></a>8. run方法和start方法有什么区别?</h3><ul>
<li>run()方法是线程的执行体、是线程执行的代码块，如果直接调用run（）方法，那么该方法会在当前线程中执行，而不是创建一个线程。</li>
<li>Start（）方法用于启动一个新的线程，启动线程的同时能够自动的调用run（）方法，在新的线程中执行线程操作。</li>
</ul>
<p>所以两者的区别为：start（）方法是用于启动新的线程、而run（）方法是用于定义线程执行的操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>         System.out.println(<span class="hljs-string">"Thread running: "</span> + i);<br>      }<br>   }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>      <span class="hljs-comment">// 创建线程实例</span><br>      <span class="hljs-type">MyThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><br>      <span class="hljs-comment">// 直接调用run()方法</span><br>      t.run();<br><br>      <span class="hljs-comment">// 调用start()方法，启动新线程</span><br>      t.start();<br>   }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="9-谈谈对spring的理解"><a href="#9-谈谈对spring的理解" class="headerlink" title="9.谈谈对spring的理解"></a>9.谈谈对spring的理解</h3><p>他是一个开源的java程序框架，它基于IOC（控制反转）和AOP（面向切面编程）的开发模式，便于系统程序的开发以及维护，它主要特点是<strong>轻量级</strong>（低侵入、低耦合）的开发</p>
<ul>
<li>Core Container：包含核心容器和依赖注入功能，提供了BeanFactory、ApplicationContext等容器和Bean，Bean的生命周期、属性注入等相关功能</li>
<li>AOP提供了面向切面的编程，可以通过配置来实现日志记录，性能监控，事务管理等横向领域从而提高系统的可重用性和可维护性</li>
<li>Data Access/Intergration：提供了对数据库访问和继承的支持包括JDBC、ORM、NoSQL等数据库</li>
<li>Web：提供了对Web开发的支持、包括MVC、REST、Web服务和WebSocket等</li>
<li>Test：提供了对单元测试和集成测试的支持</li>
</ul>
<p>Spring框架的核心是IOC容器，IOC容器负责对象的实例化、配置和管理对象（Bean）、并将它们之间的依赖关系进行注入。spring框架通过IOC容器实现了高度的可重用性和松耦合性、只需要关心Bean的定义和依赖关系的配置，不需要关心他如何被创建和管理</p>
<p>另外AOP功能可以将日志、安全、事务等与核心业务逻辑分离使得系统更加容易被维护和扩展。</p>
<p>IOC执行流程：</p>
<ol>
<li>读取标注的配置文件，找到配置信息对应的类名</li>
<li>使用反射API，基于类名进行实例化对象</li>
<li>将对象实例，通过构造函数或者setter传递给所实例化的对象</li>
</ol>
<p>AOP编程：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> service;<br> <span class="hljs-comment">//在 Packge【service】下创建 【ProductService】类：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeService</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"doSomeService"</span>);<br>    }<br>}<br><span class="hljs-comment">//在xml文件中装配该bean</span><br>&lt;bean name=<span class="hljs-string">"productService"</span> class=<span class="hljs-string">"service.ProductService"</span> /&gt;<br><span class="hljs-comment">//在【TestSpring】中编写测试代码在 Packge【aspect】下准备日志切面 【LoggerAspect】类：</span><br><span class="hljs-keyword">package</span> aspect;<br> <br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerAspect</span> {<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">log</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        System.out.println(<span class="hljs-string">"start log:"</span> + joinPoint.getSignature().getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br>        System.out.println(<span class="hljs-string">"end log:"</span> + joinPoint.getSignature().getName());<br>        <span class="hljs-keyword">return</span> object;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>在xml文件中声明业务对象和日志切面</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">"http://www.springframework.org/schema/aop"</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"productService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"service.ProductService"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loggerAspect"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"aspect.LoggerAspect"</span>/&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- 配置AOP --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- where：在哪些地方（包.类.方法）做增加 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loggerCutpoint"</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* service.ProductService.*(..)) "</span>/&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- what:做什么增强 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"logAspect"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"loggerAspect"</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- when:在什么时机（方法前/后/前后） --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"loggerCutpoint"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"log"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="10-spring-的-bean-是什么时候初始化的？"><a href="#10-spring-的-bean-是什么时候初始化的？" class="headerlink" title="10. spring 的 bean 是什么时候初始化的？"></a>10. spring 的 bean 是什么时候初始化的？</h3><p>Bean的初始化可以分为以下几个阶段：</p>
<ol>
<li>实例化bean对象：容器根据bean的配置信息创建bean实例，可以通过构造函数或工厂方法来实现</li>
<li>设置bean的属性值：容器将bean的属性值注入到bean实例中、可以通过依赖注入或者其他方式来实现</li>
<li>调用bean的初始化方法：容器调用bean实例的初始化方法可以通过实现InitializingBean接口在配置文件中指定init-method方法来实现</li>
<li>使用bean：容器将初始化后的bean实例返回给调用者，调用者可以使用该实例来完成相应的业务逻辑</li>
</ol>
<p>大概就是：spring容器启动时，先扫描配置文件或者注解，实例化bean对象，并将bean注册到容器中，当调用bean时，容器会根据bean的依赖关系和初始化顺序来初始化bean；需要注意的是如果bean实现了DisposableBean接口或在配置文件中指定了destroymethod方法当容器关闭的时候，会调用bean实例的销毁方法来释放资源</p>
<p>在Spring容器启动时，会扫描配置文件或注解，实例化bean对象，并将bean注册到容器中，在默认情况下，Spring只会在使用到某个bean时进行初始化，即懒加载模式，而不是一次性初始化所有的bean，这样可以节约系统资源和提高应用程序的启动速度。不过也可以将所有的bean在启动时初始化，只需要在配置文件中加入lazy-init属性为false 或者在bean的配置中设置@lazy注解为false来改变Bean的初始化方式。</p>
<h3 id="11-spring的bean默认是单例还是多例的"><a href="#11-spring的bean默认是单例还是多例的" class="headerlink" title="11. spring的bean默认是单例还是多例的"></a>11. spring的bean默认是单例还是多例的</h3><p>默认时单例的，也就是说Spring容器在启动的时候会创建Bean的唯一实例，并在后续的请求中共享该实例，这样可以减少程序中对象的创造次数和销毁次数，提高效率，对于单例的bean，Spring容器在启动时就会将Bean实例化并缓存起来，每次请求后缓存中的Bean，因此单例的Bean需要注意线程安全问题，尤其是在多线程的情况下需要进行合适的同步处理，否则会导致并发访问的问题</p>
<p>他也支持多例Bean，即每次请求都会创建一个新的Bean，对于多例的Bean容器不会缓存Bean实例而在每次请求时创建一个新的实例。如果需要使用多例可以在Bean配置文件中或者注解中设置scope属性为prototype</p>
<h3 id="12-对事务的理解？"><a href="#12-对事务的理解？" class="headerlink" title="12. 对事务的理解？"></a>12. 对事务的理解？</h3><p>就是指作为一个单独的逻辑工作单元执行一系列的操作，要么所有的操作全部执行成功，要么其中一步或者多步操作执行失败全部回滚到事务开始的状态，不会出现部分执行成功部分执行失败的场景，它可以保证数据的一致性。</p>
<p>在关系数据库中事务由一组SQL语句组成，可以通过提交commit或者回滚（rollback）来进行事务对数据库的操作：</p>
<ul>
<li>原子性：事务是一个原子的操作，要么全部执行成功，要么全部回滚，是个不可再分的单元</li>
<li>一致性：事务执行前和执行后，数据库必须处于一致的状态，在执行事务期间，所有的操作结果都是符合预期的规则和约束</li>
<li>隔离性：多个事务的执行是相互隔离的，不会相互影响；</li>
<li>持久性：一旦事务提交成功，其所作的修改是永久保存在数据库中，并能够在数据库重启后恢复</li>
</ul>
<p>在spring框架中事务通常使用声明式事务管理来实现在方法或者类的上面添加@Transaction注解。事务的隔离级别：读未提交、 读提交、可重复读、序列化</p>
<ul>
<li><p>脏读：读取了另一个事务的未提交数据。</p>
</li>
<li><p>不可重复读：多次读取统一数据的结果不一致，该数据被另一个事务更新并提交了</p>
</li>
<li><p>幻读：多次查询的结果不一致，后查询的结果比之前增加或者减少了数据</p>
</li>
</ul>
<h3 id="13-java中事务的回滚"><a href="#13-java中事务的回滚" class="headerlink" title="13. java中事务的回滚"></a>13. java中事务的回滚</h3><p>编程式可以使用TransactionTemplate 可以调用其execute方法执行事务逻辑并用tryCache来捕获异常，通过setRollbackOnly方法来标记回滚</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> TransactionTemplate transactionTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTransaction</span><span class="hljs-params">()</span> {<br>    transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallbackWithoutResult</span>() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus status)</span> {<br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-comment">// 在这里执行事务操作</span><br>                <span class="hljs-comment">// 如果发生异常，则抛出异常</span><br>            } <span class="hljs-keyword">catch</span> (Exception e) {<br>                status.setRollbackOnly(); <span class="hljs-comment">// 标记回滚</span><br>            }<br>        }<br>    });<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>注解式：可以声明事务的级别 isolation来进行事务的管理方式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTransaction</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 在这里执行事务操作</span><br>    <span class="hljs-comment">// 如果发生异常，则抛出异常</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="14-springboot项目中-controller层接收前端的参数传递"><a href="#14-springboot项目中-controller层接收前端的参数传递" class="headerlink" title="14. springboot项目中 controller层接收前端的参数传递"></a>14. springboot项目中 controller层接收前端的参数传递</h3><ol>
<li>通过@RequestParam注解接收参数</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/hello")</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam("name")</span> String name, Model model)</span> {<br>    model.addAttribute(<span class="hljs-string">"name"</span>, name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;<br>}<br><span class="hljs-comment">//该方法@RequestParam注解将name参数绑定到name方法的参数上</span><br></code></pre></td></tr></tbody></table></figure>
<ol>
<li>通过@PathVariable注解接收路径的参数实例如下：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/users/{id}", method = RequestMethod.GET)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> Long id)</span> {<br>    <span class="hljs-keyword">return</span> userService.getUserById(id);<br>}<br></code></pre></td></tr></tbody></table></figure>
<ol>
<li>通过RequestBody注解接收请求体的参数</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value="/users",method=RequestMethod.POST)</span><br>pubilc <span class="hljs-keyword">void</span> <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>{<br>    userService.createUser(user);<br>}<br><span class="hljs-comment">//上面的例子中，通过@RequestBody注解将请求体中的JSON/XML格式的参数绑定到User对象上。</span><br></code></pre></td></tr></tbody></table></figure>
<ol>
<li>通过@RequestHeader注解接收请求头的参数</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/hello")</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader("User-Agent")</span> String userAgent, Model model)</span> {<br>    model.addAttribute(<span class="hljs-string">"userAgent"</span>, userAgent);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="15-SpringMVC执行流程？"><a href="#15-SpringMVC执行流程？" class="headerlink" title="15. SpringMVC执行流程？"></a>15. SpringMVC执行流程？</h3><p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/5220087-3c0f59d3c39a12dd.png" alt="img"></p>
<ol>
<li>用户发送请求到前端控制器DispacherServlet</li>
<li>DispacherServlet收到请求调用处理器映射器HandlerMapping</li>
<li>处理器映射器根据请求的url找到具体的处理器，生成处理器执行链HandlerExecutitonChain(保括处理器对象和处理器拦截器)一并返回给DisptcherServlet</li>
<li>DispatcherServlet根据处理器Handler获取处理适配器HandlerAdapter执行HandlerAdapter的一系列操作，如参数封装，数据格式转换，数据的验证等操作</li>
<li>执行处理器Handler（Controller也叫做页面控制器）</li>
<li>Handler执行完成后返回ModelAndView</li>
<li>HandlerAdapter将Handler执行的结果ModelAndView返回到DispacherServlet</li>
<li>DispacherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体的View</li>
<li>DispacherServlet对View进行渲染视图（即将模型数据model填充至视图）</li>
<li>DispatcherServlet相应用户</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8a20c547e245">https://www.jianshu.com/p/8a20c547e245</a></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>客户端发送请求到DispatcherServlet；<br><span class="hljs-comment">//客户端通过浏览器向Web应用程序发送请求，请求到达Web容器（如Tomcat），Web容器通过Servlet规范将请求交给DispatcherServlet处理。</span><br><br><span class="hljs-number">2.</span>DispatcherServlet 根据请求的URL调用HandlerMapping，找到对应的Handler（Controller）；<br><span class="hljs-comment">//DispatcherServlet通过HandlerMapping（通常是RequestMappingHandlerMapping）找到对应的Handler（Controller）。HandlerMapping将请求映射到对应的Controller方法上，根据注解（如@RequestMapping）或配置文件（如XML）中的信息来确定对应的Controller方法。</span><br><span class="hljs-number">3.</span>Handler执行业务逻辑，返回ModelAndView对象；<br><span class="hljs-comment">//DispatcherServlet调用找到的Controller方法，并将请求参数（如URL参数或请求体）传递给Controller方法。Controller方法执行业务逻辑，然后返回一个ModelAndView对象，其中包含要渲染的视图名称和模型数据。</span><br>    <br><span class="hljs-number">4.</span>DispatcherServlet根据ViewResolver找到ModelAndView对象对应的View；<br><span class="hljs-comment">//DispatcherServlet将ModelAndView对象传递给ViewResolver，ViewResolver根据配置找到对应的View。ViewResolver可以使用多种类型的视图解析器（如InternalResourceViewResolver、VelocityViewResolver等），每种视图解析器对应一种视图类型。</span><br><span class="hljs-number">5.</span>View将模型渲染成HTML，返回给客户端。<br><span class="hljs-comment">//View将模型数据渲染成HTML，返回给DispatcherServlet，DispatcherServlet将HTML返回给客户端，客户端浏览器显示HTML。</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="16-如何理解前后端分离"><a href="#16-如何理解前后端分离" class="headerlink" title="16. 如何理解前后端分离"></a>16. 如何理解前后端分离</h3><p>前后端分离是一种应用架构模式，将web应用程序的前端和后端分离成两个工程，他们通过接口通信，前端和后端可以使用不同的编程语言进行开发从而提高开发效率，分离架构模式包括：</p>
<ol>
<li>前端端开发人员使用HTML、CSS、JavaScript等技术栈，开发Web应用程序界面和交互逻辑，前端程序运行在web浏览器上。</li>
<li>后端使用java、python、Node.s等编程语言开发web应用程序的业务逻辑和数据处理路逻辑，后端运行在Web服务器上。</li>
<li>接口设计：前后端开发人员协商并设计接口、接口定义了前后端应用程序之间的数据传输格式和协议，可以使用RESTful API接口来实现。</li>
<li>接口开发：后端根据接口设计，开发接口端的服务，提供前端应用程序访问后端数据和服务能力</li>
<li>前端集成：前端开发人员将接口集成到前端应用程序中，使用Ajax等技术从后端获取数据</li>
</ol>
<h3 id="17-mybatis和mybatisplus的区别"><a href="#17-mybatis和mybatisplus的区别" class="headerlink" title="17. mybatis和mybatisplus的区别"></a>17. mybatis和mybatisplus的区别</h3><p><strong>mybaits</strong> </p>
<ol>
<li>没有第三方依赖的数据访问框架、封装了JDBC底层访问数据库的细节。</li>
<li>解除了SQL语句与代码的耦合，提供了DAO（数据库访问层），将业务逻辑和数据访问逻辑分离</li>
<li>使用原生的SQL语句来完成数据库的访问，可以用xml文件或者注解的方式编写SQL语句，方便维护、优化和统一性管理</li>
<li>所有的SQL语句都是自己写的，这导致过渡的依赖数据库SQL语句，移植性差</li>
<li>支持驼峰命名映射xml文件设置对象和数据库字段映射</li>
<li>手动解析，实体关系映射转换为mybatis内部对象，然后注入容器进行操作</li>
<li>不支持lambd形式调用</li>
<li>xml文件编写SQL语句方式，不适合重载，不支持DAO类方法的重载，因为xml标签中的id唯一</li>
<li>xml文件提供了动态SQL标签支持动态编写SQL</li>
</ol>
<p><strong>Mybatis-plus</strong></p>
<ul>
<li>一键移植：可以在mybaits基础上进行扩展，只做增强不做改变</li>
<li>损耗小：内置了基本的单表CRUD语句，性能无损耗，面向对象操作</li>
<li>通用的CRUD操作，内置的CRUD方法是通用的泛型接口，DAO类需要实现BaseMapper接口、实体类需要序列化，Service类同样有相应的泛型接口。</li>
<li>自动解析：实体关系映射转换为Mybatis内部对象，然后注入容器操作</li>
<li>支持Lambda调用</li>
<li>可以预防SQL注入：内置SQL注入剥离器，有效预防SQL注入攻击</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7152141448321138718">https://juejin.cn/post/7152141448321138718</a></p>
<ul>
<li>Mybatis-plus式mybatis的升级版，mybatisplus在增加了支持lambda形式调用并在实体类配置中添加了：@TableName(value=””)、@TableId(value=””)、@TableField（value=””）等三个注解用来映射数据库表及表字段与实体类的关系。</li>
<li>增加了：主键策略、分页插件、全局拦截插件、性能分析插件等。</li>
</ul>
<h3 id="18-mp的查询怎么做比较多？"><a href="#18-mp的查询怎么做比较多？" class="headerlink" title="18. mp的查询怎么做比较多？"></a>18. mp的查询怎么做比较多？</h3><ul>
<li>条件构造器：使用MP提供的Wrapper类通过条件构造查询条件进行查询，Wrapper类中封装了常用的查询条件方法，例如eq、ne、like、in等可以根据需要自由的组合查询条件</li>
<li>分页查询，mp提供分页查询工具Page机型分页查询</li>
<li>Lambda查询：使用lambda表达式进行查询可以实现类型安全的查询，需要传入一个实体</li>
<li>Chain查询：使用链式调用的方法进行查询可以简化查询语句提高代码的可读性</li>
</ul>
<h3 id="19-mp可以做多表的联合查询吗？"><a href="#19-mp可以做多表的联合查询吗？" class="headerlink" title="19.  mp可以做多表的联合查询吗？"></a>19.  mp可以做多表的联合查询吗？</h3><p>可以在xml文件中书写对应的sql语句然后注入对应的方法</p>
<p>也可以在@Select方法中直接编写SQL语句注入</p>
<h3 id="20-对索引的理解？什么情况下需要建立索引？"><a href="#20-对索引的理解？什么情况下需要建立索引？" class="headerlink" title="20. 对索引的理解？什么情况下需要建立索引？"></a>20. 对索引的理解？什么情况下需要建立索引？</h3><p>可以将索引当作字典的目录，我们查询数据就是根据索引建立起来的目录进行查找，常规的SQL表如果不定义索引（默认主键也就是索引）会进行全表扫描浪费性能，所以一般来书索引能优化性能。</p>
<p>索引的分类：</p>
<ol>
<li>主键索引，是特殊的唯一索引</li>
<li>普通索引也成为单列索引</li>
<li>组合索引</li>
<li>唯一索引</li>
<li>全文索引</li>
</ol>
<p>根据数据结构分类：哈希索引、数组索引、B+树索引</p>
<p>根据物理存储分类：聚簇索引和非聚簇索引</p>
<p>建立索引的情况：</p>
<ul>
<li>索引不是越多越好，维护起来耗费空间和性能</li>
<li>对于数据量少的不建立索引</li>
<li>对于频繁查找的，数据量大的字段建立索引</li>
<li>给频繁作为排序和分组的字段建立索引</li>
<li>给条件表达式中经常用到不同值的列添加索引</li>
</ul>
<h3 id="21-慢查询指令"><a href="#21-慢查询指令" class="headerlink" title="21. 慢查询指令"></a>21. 慢查询指令</h3><p>慢查询是用来记录或分析MySQL数据库中执行时间超过一定阈值的查询语句，可以通过以下几种方式启动或者配置慢查询指令：</p>
<ul>
<li><code>set global slow_query_log='ON';</code>开启慢查询日志功能</li>
<li><code>set global slow_query_log_file=&lt;some file name&gt;</code>；设置慢查询日志文件的路径和名称</li>
<li><code>set global long_query_time =&lt;some value&gt;</code> ;设置慢查询的阈值，单位为秒</li>
<li><code>set global log_queries_not_using_index='ON'</code>;记录没有使用索引的查询语句</li>
</ul>
<p>在my.cnf或者my.ini配置文件中添加以下选项</p>
<ul>
<li><code>log_slow_queries=1</code> ;开启慢查询日志功能</li>
<li><code>slow_query_log_file = &lt;some file name&gt;;</code> 设置慢查询日志文件的路径和名称。</li>
<li><code>long_query_time = &lt;some value&gt;;</code> 设置慢查询的阈值，单位为秒。</li>
<li><code>log_queries_not_using_indexes = 1;</code> 记录没有使用索引的查询语句。</li>
</ul>
<h3 id="22-单句sql如何判断是否走了索引？"><a href="#22-单句sql如何判断是否走了索引？" class="headerlink" title="22. 单句sql如何判断是否走了索引？"></a>22. 单句sql如何判断是否走了索引？</h3><p>可以使用EXPLAIN关键字判断是否走索引，他是个模拟过程，实际上并不执行，它可以用来查看MYSQL执行查询时的执行计划、包括表的链接方式，使用索引、扫描的行数</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/image-20230225154315271.png" alt="image-20230225154315271"></p>
<p>执行上述语句会放回详细的查询计划信息：包括使用的索引、扫描的行数、连接方式等，其中的key表示索引，如果为NULL则未使用索引；</p>
<h3 id="23-数据库的锁？"><a href="#23-数据库的锁？" class="headerlink" title="23.数据库的锁？"></a>23.数据库的锁？</h3><p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/Zu4vlv7L2S.png!large" alt="一张图彻底搞懂 MySQL 的锁机制"></p>
<p>按照锁的类型分为表锁、行锁、页锁</p>
<ul>
<li>表锁：<ul>
<li>读锁：也叫做共享锁，针对同一份数据多个读操作可以同时进行互不影响(select)</li>
<li>写锁：排他锁，当前操作没完成之前会阻塞其他读和写操作（update\insert\delete）</li>
<li>默认存储引擎：MyISAM</li>
<li>特点：对整张表加锁，开销小、加锁快、无死锁、所得粒度大、发生锁的冲突概率大并发性低</li>
</ul>
</li>
<li>行锁：<ul>
<li>读锁：共享锁，允许一个事务去读一行，组织其他事务获得相同数据集的排他锁</li>
<li>写锁：排它锁，允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享锁和排它锁</li>
<li>意向共享锁：一个事务给另一个数据行加共享锁时必须先获得表的IS锁</li>
<li>意向排他锁：一个事务给一个数据行加排它锁时必须先获得该表的IX锁</li>
<li>默认存储引擎：InnoDB</li>
<li>特点：对一行数据加锁、开销大、加锁慢、会出现死锁、锁的粒度小、发生锁冲突概率最低、并发性高</li>
<li>带来问题：读未提交、脏读、不可重复度、幻读</li>
</ul>
</li>
<li>页锁<ul>
<li>开销、加锁时间和锁粒度介于表锁和行锁之间，会出现死锁，并发处理能力一般</li>
</ul>
</li>
</ul>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/ZEw4DFkZI2.png!large" alt="一张图彻底搞懂 MySQL 的锁机制"></p>
<p>悲观锁：是指在访问数据之前先对数据加锁，防止其他事务修改数据，直到当前事务完成才释放锁。悲观锁适合写多读少的场景，可以避免脏读、不可重复读和幻读等问题，但是会降低数据库的并发性能，增加死锁或超时的风险。</p>
<p>乐观锁：是指在访问数据时不加锁，而是在提交更新时检查是否有其他事务修改了数据。乐观锁适合读多写少的场景，可以提高数据库的效率和吞吐量，但是会增加程序的复杂度，可能导致数据丢失或重试失败。</p>
<h3 id="24-锁和锁的冲突通常发生在？"><a href="#24-锁和锁的冲突通常发生在？" class="headerlink" title="24. 锁和锁的冲突通常发生在？"></a>24. 锁和锁的冲突通常发生在？</h3><ol>
<li>并发的访问相同数据：当多个事务并发访问相同数据时，由于每个事务都需要独占访问权限就可能产生锁冲突</li>
<li>长事务：当一个事务长时间占用资源而没有释放的时，其他事务可能因为等待该事务而产生锁冲突</li>
<li>数据库死锁：当多个事务等待对方释放资源的时候，就可能产生死锁，导致所有的事务无法继续执行。</li>
</ol>
<p>采取措施：</p>
<ul>
<li>优化SQL语句尽量减少对数据库的访问次数，减少锁的竞争机会</li>
<li>提高事务的执行效率：减少事务的执行时间、降低锁的冲突概率</li>
<li>降低事务的隔离级别：降低事务的隔离级别可以减少锁的竞争，但是也会降低数据的一致性和完整性</li>
<li>使用分布式锁：在分布式系统中，可以使用分布式锁来避免锁和锁的冲突产生</li>
</ul>
<h3 id="25-后端接口性能优化"><a href="#25-后端接口性能优化" class="headerlink" title="25.后端接口性能优化"></a>25.后端接口性能优化</h3><ol>
<li><p>善于利用异步编程</p>
<ul>
<li><p>利用多线程实现异步 ：使用自定义的TreadPool来实现多线程或者CompletableFuture</p>
</li>
<li><p>使用MQ中间件实现异步如分布式消息的中间件：rabbitMQ，kafka等</p>
</li>
</ul>
</li>
<li><p>数据量大的时候使用分批与分量操作</p>
<ul>
<li>避免for中操作数据库可以使用Mybatis-plus封装好的批处理API</li>
<li>避免在for中进行rpc调用</li>
</ul>
</li>
<li><p>避免大事务</p>
<ul>
<li>​    尽量少使用@Transactional注解，推荐使用编程式的事务</li>
</ul>
</li>
<li><p>优化SQL慢查询</p>
<ul>
<li>关键词建立索引并且用上索引</li>
<li>SQL复杂且慢可以使用java代码来实现对应逻辑</li>
<li>对数据库进行分表管理</li>
<li>旧数据访问较少可以对数据进行冷热分离</li>
</ul>
</li>
<li><p>利用Redis作为分布式缓存</p>
</li>
<li><p>利用Caffeine作为本地缓存</p>
</li>
<li><p>控制好锁的粒度：锁的粒度太大能影响系统的吞吐量</p>
</li>
</ol>
<p>当一个接口相应特别慢的时候可以从：</p>
<ol>
<li>查看系统资源的占用情况CPU、内存、磁盘、和网络看是否需要升级</li>
<li>分析数据库查询的性能：查看数据库的查询日志、执行计划、索引的实行情况确定是否存在慢查询和索引失效等问题</li>
<li>分析日志和监控数据：通过查看系统日志和监控数据，找出异常情况和系统瓶颈进而进行优化</li>
</ol>
<h3 id="26-什么时候用缓存？Redis是什么数据库？数据存储在哪里"><a href="#26-什么时候用缓存？Redis是什么数据库？数据存储在哪里" class="headerlink" title="26. 什么时候用缓存？Redis是什么数据库？数据存储在哪里"></a>26. 什么时候用缓存？Redis是什么数据库？数据存储在哪里</h3><p>缓存通常使用在：</p>
<ul>
<li>数据频繁的被访问</li>
<li>数据不经常变动</li>
<li>数据量较大</li>
</ul>
<p>Redis是一个基于内存的数据存储系统，它支持多种数据结构、它的本质是个Key—value键值对进行存储，他提供了数据的持久化、事务、发布订阅、Lua脚本、Redis是一个高性能得数据库、被使用在WEb应用程序、分布式系统、缓存系统等</p>
<p>Redis数据存储在内存中、可以通过RDB和AOF两种持久化方式将数据写入磁盘防止数据丢失、Redis也支持主从复制和哨兵机制，可以实现高可用性和数据备份等功能。</p>
<h3 id="27-java的业务逻辑实现在那一层"><a href="#27-java的业务逻辑实现在那一层" class="headerlink" title="27. java的业务逻辑实现在那一层"></a>27. java的业务逻辑实现在那一层</h3><p>通常在Service层实现也成为业务逻辑层是介于控制层和数据访问层之间的一层，主要负责业务逻辑的处理和控制</p>
<h3 id="28-service层的代码怎么去优化，什么方式去写会有性能问题？"><a href="#28-service层的代码怎么去优化，什么方式去写会有性能问题？" class="headerlink" title="28. service层的代码怎么去优化，什么方式去写会有性能问题？"></a>28. service层的代码怎么去优化，什么方式去写会有性能问题？</h3><ol>
<li>减少数据库的访问来提高性能，可以使用缓存、课批处理来减少数据库的访问</li>
<li>优化算法和数据结构：降低查询的算法时间复杂度，如果数据量大时，可以采用分页查询方式、减少单次查询的数据量</li>
<li>使用多线程：在服务层中采用多线程来处理大量的业务场景</li>
<li>避免重复计算：在服务层可能存在多个方法需要进行相同的计算，我们可以将这些计算结果缓存起来，避免重复计算</li>
<li>使用合适的框架，减少代码的编写量，例如使用缓存框架减少数据库的访问次数</li>
</ol>
<p>存在性能问题：</p>
<ol>
<li>过渡依赖ORM框架：</li>
<li>过度使用同步的方法</li>
<li>使用第三方的库多</li>
<li>过度使用数据库的链接</li>
</ol>
<h3 id="29-mysql数据量大怎么进行优化"><a href="#29-mysql数据量大怎么进行优化" class="headerlink" title="29. mysql数据量大怎么进行优化"></a>29. mysql数据量大怎么进行优化</h3><ul>
<li>优化表结构建立索引、避免过多的冗余字段、提高查询性能</li>
<li>对大量数据进行批处理</li>
<li>引入缓存框架如Redis来将部分数据缓存到内存提高访问速度</li>
<li>对数据进行分库分表管理</li>
<li>查询语句的优化避免使用复杂的SQL语句，使用Explain名能查看SQL执行计划，避免全表扫描</li>
<li>数据库连接池优化，合理配置数据库连接池的大小、链接时间、减少资源的占用避免频繁的数据库链接与关闭</li>
</ul>
<h3 id="30-git提交代码出现冲突"><a href="#30-git提交代码出现冲突" class="headerlink" title="30. git提交代码出现冲突"></a>30. git提交代码出现冲突</h3><p>冲突1:当commit以后执行git pull —rebase出现冲突</p>
<ol>
<li>git status 找到冲突文件，解决冲突</li>
<li>执行git add xxx(xxx为冲突文件全路径)</li>
<li>执行 git rebase —continue</li>
<li>执行 git pull —rebase</li>
<li>执行 git push</li>
</ol>
<p>当执行了git stash然后幼虫服务器上pull了最新代码（git pull —rebase）</p>
<ol>
<li>git status 找到冲突文件，解决冲突</li>
<li>执行git add xxx (xxx为冲突文件全路径)</li>
<li>git commit</li>
<li>git pull -rebase</li>
<li>git push</li>
</ol>
<p>在解决冲突之前可以使用git fetch来获取最新代码，避免代码冲突的发生</p>
<h3 id="31-git和SDK的区别"><a href="#31-git和SDK的区别" class="headerlink" title="31. git和SDK的区别"></a>31. git和SDK的区别</h3><p>Git是一个分布式版本的控制系统可以帮助开发者进行版本管理、代码协作和代码备份等操作，开发者可以通过git来管理自己的代码库，跟踪代码的变化并进行版本的回滚分支的合并等操作</p>
<p>SDK时软件开发包。包含了软件开发过程中的各种工具、库文档等资源</p>
<p>总的来说git时用来进行版本控制的工具，SDK是用来辅助开发者进行软件开发的工具包</p>
<h3 id="32-git的分支什么时候用？"><a href="#32-git的分支什么时候用？" class="headerlink" title="32. git的分支什么时候用？"></a>32. git的分支什么时候用？</h3><p>git branch 是指在代码仓库中创建一个独立的开发分支，避免相互打扰，分支的使用情况：</p>
<ol>
<li>并行开发</li>
<li>版本管理</li>
<li>修复bug</li>
</ol>
<h3 id="33-springboot的理解"><a href="#33-springboot的理解" class="headerlink" title="33. springboot的理解"></a>33. springboot的理解</h3><p>springboot是一个基于spring的开源框架他为开发人员提供了一种快速创建spring的应用程序，简化了spring的配置和部署过程提供了大量的开箱即用的特性，如web内嵌服务器，自动配置、健康检查、度量指标、也提供了许多可插拔的组件，他也支持多种开发场景如Web应用程序、Restful服务、批处理任务、微服务。他也集成了Spring Data\Spring Security\Spring Cloud等框架</p>
<h3 id="34-Redis如何实现分布式的session的？"><a href="#34-Redis如何实现分布式的session的？" class="headerlink" title="34. Redis如何实现分布式的session的？"></a>34. Redis如何实现分布式的session的？</h3><p>实现一个共享存储，将数据放到单台服务器的内存中。实现方法</p>
<ol>
<li>Redis（基于内存的Key—value）</li>
<li>mysql</li>
<li>文件服务器ceph</li>
</ol>
<p>首先引入Redis接着引入spring-session整合redis</p>
<p>修改spring-session存储配置<code>spring.session.store-type</code>默认是none，表示存储在单台服务器上</p>
<p><code>store-type: redis</code>,表示从redis中读写数据</p>
<h3 id="35-缓存预热？"><a href="#35-缓存预热？" class="headerlink" title="35. 缓存预热？"></a>35. 缓存预热？</h3><p>首先对Redis进行序列化：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yupao.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTemplateConfig</span> {<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> {<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(connectionFactory);<br>        redisTemplate.setKeySerializer(RedisSerializer.string());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>引入Spring Data Redis：因为他是一个通用的数据访问框架，定义了一组增删改查的接口 mysql、redis、jpa</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<p>接着配置Redis地址：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># redis 配置</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure>
<p>Redisson：分布式操作 Redis 的 Java 客户端，让你像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）</p>
<p><strong>设计缓存的Key：</strong></p>
<p>systemId:moduleId:func:options（不要和别人冲突）</p>
<p>yupao:user:recommed:userId</p>
<p><strong>redis内存不能无限的增加、一定要设置过期时间</strong></p>
<p>实现缓存预热：定时</p>
<ol>
<li>缓存的意义：（新增少、总用户多）</li>
<li>缓存的空间不能太大，要预留给其他缓存空间</li>
<li>缓存数据周期（每天一次）</li>
</ol>
<p>定时任务可以开启一个Spring Scheduler（SpringBoot默认整合了）</p>
<p>主类开启@EnableScheduling</p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/image-20230225195214062.png" alt="image-20230225195214062"></p>
<p>给定时任务添加@Scheduling注解指定cron表达式和执行频率(不需要背);</p>
<p><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p>
<h3 id="36-分布式锁"><a href="#36-分布式锁" class="headerlink" title="36. 分布式锁"></a>36. 分布式锁</h3><p>Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。用完锁要释放、锁要加载过期时间。</p>
<p>Redisson 是一个 java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。</strong></p>
<p>定时任务+锁</p>
<ol>
<li>waitTime 设置为 0，只抢一次，抢不到就放弃</li>
<li>注意释放锁要写在 finally 中</li>
</ol>
<p>实现代码逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">testWatchDog</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">"yupao:precachejob:docache:lock"</span>);<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">// 只有一个线程能获取到锁</span><br>        <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, TimeUnit.MILLISECONDS)) {<br>            <span class="hljs-comment">// todo 实际要执行的方法</span><br>            doSomeThings();<br>            System.out.println(<span class="hljs-string">"getLock: "</span> + Thread.currentThread().getId());<br>        }<br>    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>        System.out.println(e.getMessage());<br>    } <span class="hljs-keyword">finally</span> {<br>        <span class="hljs-comment">// 只能释放自己的锁</span><br>        <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) {<br>            System.out.println(<span class="hljs-string">"unLock: "</span> + Thread.currentThread().getId());<br>            lock.unlock();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="37-分布式锁的实现原理？"><a href="#37-分布式锁的实现原理？" class="headerlink" title="37. 分布式锁的实现原理？"></a>37. 分布式锁的实现原理？</h3><p>它是在分布式系统总为了保证数据的一致性和避免多个客户端同时对共享资源进行修改而引入的一种同步机制，在实现需要满足以下两个条件：</p>
<ol>
<li>互斥性：同一时间只能有一个客户端获得锁，其他客户端需要等待锁的释放</li>
<li>安全性：在客户端获取锁之后，即使客户端的崩溃或者网络异常，锁应该自动释放，避免死锁和数据不一致。</li>
</ol>
<p>常见的使用方式基于数据库，基于Redis的实现方式、基于Zookeeper的实现方式，这三种的实现核心都是基于同步机制。</p>
<h3 id="38-什么是集群？一个项目改成集群需要注意什么？"><a href="#38-什么是集群？一个项目改成集群需要注意什么？" class="headerlink" title="38. 什么是集群？一个项目改成集群需要注意什么？"></a>38. 什么是集群？一个项目改成集群需要注意什么？</h3><p>集群式多个计算机或者服务器连接起来形成一个整体，通过共享资源和分配任务来提高系统的可用性和性能，在集群中，每个节点都可以独立工作，但是通过协调和通信，共同完成复杂的任务和处理大量的请求。</p>
<p>将一个项目修改成集群需要注意：</p>
<ol>
<li>分布式架构的设计</li>
</ol>
<p>为了实现集群，需要将系统的架构设计成分布式架构，将不同的功能模块拆分到不同的节点上，通过消息中间件、负载均衡器等技术协调和管理不同节点之间的通信和数据同步。</p>
<ol>
<li>数据库的选型和分库分表</li>
</ol>
<p>在分布式架构中，通常需要使用分布式数据库来管理数据，如MySQL集群、MongoDB集群等。同时，为了提高数据库的性能，需要进行分库分表来将数据水平切分到多个节点上</p>
<ol>
<li>负载均衡和容错机制</li>
</ol>
<p>为了保证系统的可用性和性能，需要使用负载均衡器来将请求均衡地分配到不同的节点上，并通过容错机制来处理节点故障和网络异常等问题。</p>
<ol>
<li>代码和配置优化</li>
</ol>
<p>在集群中，需要对代码和配置进行优化，如减少锁的使用、优化SQL查询、合理配置缓存等，以提高系统的性能和可伸缩性。</p>
<ol>
<li>监控和调试</li>
</ol>
<p>在集群中，需要使用监控和调试工具来实时监测系统的运行状态和性能指标，及时发现和解决问题，保证系统的稳定性和可靠性。</p>
<h3 id="39-mybatis-plus执行流程工作原理"><a href="#39-mybatis-plus执行流程工作原理" class="headerlink" title="39. mybatis-plus执行流程工作原理"></a>39. mybatis-plus执行流程工作原理</h3><ol>
<li>读取核心配置文件<code>mybatis-config.xml</code>并返回<code>InputStream</code>流对象。</li>
<li>根据<code>InputStream</code>流对象解析出<code>Configuration</code>对象，然后创建<code>SqlSessionFactory</code>工厂对象</li>
<li>根据一系列属性从<code>SqlSessionFactory</code>工厂中创建<code>SqlSession</code></li>
<li>从<code>SqlSession</code>中调用<code>Executor</code>执行数据库操作&amp;&amp;通过解析生成具体SQL指令</li>
<li>通过<code>TypeHandler(数据库与java类型转换)</code>对执行结果进行二次封装</li>
<li>提交与事务处理</li>
</ol>
<h3 id="40-JDK8的新特性"><a href="#40-JDK8的新特性" class="headerlink" title="40. JDK8的新特性"></a>40. JDK8的新特性</h3><ol>
<li>lambda表达式：允许开发人员更简洁的写代码，而且支持函数式编程</li>
<li>方法引用：式lambda表达式的一个扩展，允许直接引用现有的方法和构造函数；</li>
<li>默认方法：允许想接口添加新方法而不破坏现有的方法</li>
<li>Stream API：它支持对集合数组等数据结构进行函数式的操作，如过滤、映射、排序等</li>
<li>Date and time API：全新的日期和时间API更好的处理日期和时间提供了LocalDate、LocalTime</li>
<li>CompletableFuture类：CompletableFuture类是Java 8中的一个新的异步编程API，它支持非阻塞的、基于回调的编程方式。CompletableFuture可以用于并行处理、异步任务等场景，使得代码更加简洁和易于理解。</li>
</ol>
<h3 id="41-git常用命令"><a href="#41-git常用命令" class="headerlink" title="41. git常用命令"></a>41. git常用命令</h3><p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/24bafa1f034d193c81f57897efd086e2.jpg" alt="img"></p>
<ul>
<li>git init[project-name]</li>
<li>git clone url</li>
<li>git add 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt;提交某些文件到缓存区</li>
<li>git diff 查验当前代码add后 会add那些内容</li>
<li>git diff —staged查看当前commit提交后，会提交那些内容</li>
<li>git status查看当前分支的状态</li>
<li>git pull &lt;远程仓库名&gt;&lt;远程分支名&gt;拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有的diff信息</li>
<li>git commit —amend[file1][file2]重做上一次的commit并指定文件的新变化</li>
</ul>
<p>分支操作：</p>
<ul>
<li>git branch 查看本地分支</li>
<li>git branch -r 查看所有远程分支</li>
<li>git branch -a查看本地和远程的所有分支</li>
<li>git merge &lt;分支名&gt;合并分支</li>
</ul>
<h3 id="42-Linux的常用命令"><a href="#42-Linux的常用命令" class="headerlink" title="42. Linux的常用命令"></a>42. Linux的常用命令</h3><ul>
<li>top  查看内存、显示系统当前的进程信息</li>
<li>df -h：查看磁盘的存储状态</li>
<li>iotop：查看IO的读写</li>
<li>iotop -o：查看比较高的磁盘读写程序</li>
<li>netstat -tunIp |grep 端口号  ：查看端口号占用情况</li>
<li>Isof -i：端口号：查看端口号占用情况</li>
<li>uptime：查看报告系统运行时长及平均负载</li>
<li>ps axu：查看进程</li>
</ul>
<p>基础：</p>
<ul>
<li>ls  ：查看目录</li>
<li>ls -la：显示当前目录下所有文件的详细信息</li>
<li>cd  ：切换目录</li>
<li>cd… 返回上一级目录</li>
<li>cd…/… 返回上两级目录</li>
<li>pwd 显示当前的目录</li>
<li>touch desc.txt：在当前目录下创建文件</li>
<li>mkdir text: 在当前目录下创建目录</li>
<li>cat 查看文件内容</li>
<li>more 分页查看文件内容</li>
<li>tail  查看文件尾部内容</li>
<li>cp 拷贝</li>
<li>mv 剪切文件</li>
<li>rm 删除文件</li>
<li>find 搜索文件</li>
<li>ifconfig ：显示网络设备情况</li>
<li>netstat  ：显示网络相关信息</li>
<li>ps 显示进程状态 -ef当前所有进程</li>
<li>kill 杀死进程  kill -s 9 27810:杀死进程号为27810的进程，强制终止，系统资源无法回收</li>
<li>tar 压缩解压缩(tar -zcvf test.tar.gz ./test：打包test目录为test.tar.gz文件，-z表示用gzip压缩 —tar -zxvf test.tar.gz：解压test.tar.gz文件)</li>
<li>chown:改变文件或者目录的拥有者</li>
<li>chmod:改变文件或者目录的访问权限</li>
<li>vim 文本编译器</li>
<li>shutdown  关机和重启（-h 和-r）</li>
<li>man 帮助命令</li>
</ul>
<h3 id="43-Nginx简介"><a href="#43-Nginx简介" class="headerlink" title="43. Nginx简介"></a>43. Nginx简介</h3><p>nginx是一个软件级别的负载均衡。通过nginx的高性能，并发能力强，占用内存小，可以搭建高性能的代理服务器，同时nginx也可以作为web服务器，反向代理，动静态分离服务器。</p>
<p><strong>正向代理：</strong></p>
<p>正向代理来进行上网等功能：用户访问局域网需要通过代理服务器来访问，这种代理称为正向代理，偏重于用户进行访问如下图</p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/1534147-20200522085220242-1137326185.png" alt="1534147-20200522085220242-1137326185.png"></p>
<p><strong>反向代理：</strong></p>
<p>客户端对代理服务器无感知，客户端不需要任何配置就可以访问，用户只需要将请求发送到反向代理服务器，有反向代理服务器选择目标服务器获取数据再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器的地址，隐藏的真实的服务器的IP地址</p>
<p><strong>负载均衡：</strong></p>
<p>增加服务器的数量，然后将请求分发到各个服务器上，将原本请求到单个服务器上的情况改为请求分发到多个服务器上、将负载分发到不同分服务器我们称为负载均衡</p>
<p><strong>动静态分离：</strong></p>
<p>把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力；如图：</p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/1534147-20200522090350284-1607145726.png" alt="1534147-20200522090350284-1607145726.png"></p>
<h3 id="44-多线程常见的概念和技术"><a href="#44-多线程常见的概念和技术" class="headerlink" title="44. 多线程常见的概念和技术"></a>44. 多线程常见的概念和技术</h3><ol>
<li>线程：操作系统最小的执行单位每个线程都有自己的堆栈和程序计数器</li>
<li>线程状态：线程可以处于不同的状态：就绪、运行、新建、阻塞、终止</li>
<li>线程同步：多个线程访问共享资源需要进行同步，同步技术：互斥锁、条件变量、信号量、读写锁</li>
<li>线程池：为了避免创建和销毁线程的开销，通过线程池来管理一组线程</li>
<li>并发集合：java提供的一些线程安全的集合类如ConcurrentHashMap等</li>
</ol>
<h3 id="45-java里面的垃圾回收分几类？"><a href="#45-java里面的垃圾回收分几类？" class="headerlink" title="45. java里面的垃圾回收分几类？"></a>45. java里面的垃圾回收分几类？</h3><p>可以分为以下几类：</p>
<ul>
<li>标记清除法：标记出所有需要回收的对象，然后清除未标记的对象。这种算法的缺点是效率低，会产生内存碎片。</li>
<li>复制算法：内存空间分为两个区域，每次只使用其中一个区域，缺点是需要额外的空间。</li>
<li>标记-整理算法：标记出所有需要回收的对象，然后将存活的对象往一端移动，然后清空另一端的内存。缺点是效率低，需要移动对象。</li>
<li>分代算法：分为年轻代（复制算法、清除算法）、老年代（标记清楚法和标记整理法）和持久代（不需要进行垃圾回收）</li>
</ul>
<h3 id="46-线程的可见性"><a href="#46-线程的可见性" class="headerlink" title="46. 线程的可见性"></a>46. 线程的可见性</h3><p>当一个线程被修改了共享变量的值后，其他线程能够立即的看到这个修改，如果看不到就出现了线程的可见性问题；</p>
<p>为了解决以上问题可以使用volatile关键字来休修饰共享变量</p>
<ul>
<li>线程在读取volatile变量时，总是读取最新的值</li>
<li>线程在修改volatile变量时，总是将修改后的值立即写入主内存，而不是写入本地缓存</li>
</ul>
<p>也可以使用锁、原子变量等机制来保证线程的可见性。</p>
<h3 id="47-Array和ArrayList的区别？"><a href="#47-Array和ArrayList的区别？" class="headerlink" title="47. Array和ArrayList的区别？"></a>47. Array和ArrayList的区别？</h3><ol>
<li>内存分配方式不同Array创建的时候就需要指定数组的长度，ArrayList使用了动态数组方式来存储元素可以动态的增加和删除元素，不需要一块连续的内存空间</li>
<li>访问方式不同，Array可以直接通过数组下标来进行访问，而ArrayList需要通过get来获取指定位置上的元素</li>
<li>增删元素效率不同，Array增加和删除元素效率低因为要复制，而ArrayList可以直接使用add和remove方法来增加和删除元素</li>
<li>数据类型不同：Array可以存储基本数据类型和对象类型，而ArrayList只能存储对象类型的元素</li>
</ol>
<h3 id="48-请说说Redis的持久化机制"><a href="#48-请说说Redis的持久化机制" class="headerlink" title="48. 请说说Redis的持久化机制"></a>48. 请说说Redis的持久化机制</h3><p>Redis数据存储在内存中、可以通过RDB和AOF两种持久化方式将数据写入磁盘防止数据丢失；</p>
<ul>
<li>RDB持久化：将redis中的数据在指定的时间间隔定时的进行快照存储到硬盘上，它会将当前时间点的redis数据以快照的方式保存到磁盘上，优点数据恢复速度快，适合大规模数据的备份与恢复</li>
<li>AOF持久化：将Redis中的所有写操作以日志的形式追加到磁盘上，优点AOF的数据可靠性高，即使Rdis在持久化之前宕机，也可以通过重放日志文件的方式恢复数据库，缺点是AOF文件大，恢复速度慢</li>
</ul>
<h3 id="49-项目哪里用到了redis-怎么用？"><a href="#49-项目哪里用到了redis-怎么用？" class="headerlink" title="49. 项目哪里用到了redis 怎么用？"></a>49. 项目哪里用到了redis 怎么用？</h3><p>​    共享存储：获取当前登录的信息将数据存放在单台服务器的内存中，保证用户无论在服务器A登录还是登录服务器B都从同一个服务器内存中获取数据</p>
<p>实现方式：Session的共享实现，导入spring-session整合redis的包，修改spring-session存储配置，选择一台服务器；</p>
<p>​    Redis实现热点数据的缓主要利用Redission分布式操作，Redis实现缓存预热，首先需要一个定时任务@EnableScheduling 并给定时任务添加@Scheduling注解并且指定cron表达式</p>
<h3 id="50-InnoDB和MyISAM的区别？"><a href="#50-InnoDB和MyISAM的区别？" class="headerlink" title="50. InnoDB和MyISAM的区别？"></a>50. InnoDB和MyISAM的区别？</h3><ol>
<li>数据库表的锁定方式不同：MyISAM锁定整个表，所以在执行读操作时，不能进行写操作，而InnoDB支持行锁，可以在并发访问时对数据库进行锁定</li>
<li>数据库的事务处理能力不同：MyISAN不支持事务处理，而InnoDB支持事务处理。因此对于需要频繁更新的数据应用，使用InnoDB更为合适</li>
<li>对数据库的完整性约束不同：MyISAM不支持外键约束，而InnoDB支持外键约束</li>
<li>数据库的性能表现不同：MyISAN在执行大量的SELECT查询操作时性能比InnoDB要快，而InnoDB执行大量的INSERT和UPDATE操作时，InnoDB性能更好，特别是在高并发的情况下。</li>
</ol>
<h3 id="51-线程的创建方式有哪几种？"><a href="#51-线程的创建方式有哪几种？" class="headerlink" title="51. 线程的创建方式有哪几种？"></a>51. 线程的创建方式有哪几种？</h3><ol>
<li>继成Thread类：创建一个类，集成Thread类重写run（）方法</li>
<li>实现Runnable接口，并重写run（）方法、然后实例化Thread类，将该类作为参数传如Thread构造方法中，并且调用start（）方法启动线程</li>
<li>实现Callable接口：创建一个类，实现Callable接口，并重写call（）方法，然后使用ExecutorService提交任务并返回一个Future对象，并通过Future对象获取异步执行的结果</li>
<li>使用线程池：通过ThreadPoolExecutor等线程池类来创建线程，将任务提交给线程池进行管理，线程会自动创建线程并执行任务</li>
<li>使用匿名内部类创建线程：使用匿名内部类创建Thread类或者实现Runnable接口，并重写run（）方法然后调用start（）方法</li>
</ol>
<h3 id="52-hashMap和HashTable的区别"><a href="#52-hashMap和HashTable的区别" class="headerlink" title="52.hashMap和HashTable的区别"></a>52.hashMap和HashTable的区别</h3><ol>
<li>线程安全性不同：hashMap是线程不安全的HashTable是线程安全的，可以使用Collections.synchronizedMap方法转换为线程安全的</li>
<li>null键和值得的处理不同，Hashtable不允许键或值为null，否则会抛出空指针异常，而hashMap允许键或值为null。但需要对null处理</li>
<li>初始容量和扩容机制不同：hashTable的初始容量为11，扩容时容量会翻倍，而hashMap的初始容量为16，扩容时容量增加一倍，并且可以设置负载因子来调整扩容的时机</li>
<li>遍历方式不同：hashTable的元素是无序的，遍历时需要Enumeration，而hashMap的元素时无序的遍历可以使用iterator和forEach等方式</li>
<li>底层的实现不同：HashTable是基于哈希表的实现，而hashMap是基于哈希表和红黑树的实现；</li>
</ol>
<h3 id="53-和-的区别？"><a href="#53-和-的区别？" class="headerlink" title="53. #和$的区别？"></a>53. #和$的区别？</h3><ul>
<li><p>在linux系统中#表示root用户，$表示普通用户，在mybatis中，#表示占位符号，$表示sql拼接符号</p>
</li>
<li><p>#和$在处理传入的数据时有不同的方式。在mybatis中，#会把传入的数据都当成一个字符串来处理，并自动给其添加引号；而$则是把传入的数据直接显示在sql语句中。</p>
<ul>
<li><p>where username=# {username}，解析后为where username=”username”。</p>
</li>
<li><p>where username=$ {username}，解析后为where username=username</p>
</li>
</ul>
</li>
<li><p>#和$在防止sql注入方面有不同的效果。在mybatis中，#可以有效地防止sql注入攻击，因为它会对传入的数据进行转义；而$则不能防止sql注入攻击，因为它会直接执行传入的数据。</p>
</li>
</ul>
<p>一般来说，在JDBC能使用占位符的地方，最好优先使用#{}；在JDBC不支持使用占位符的地方，就只能使用${}，比如动态指定表名或排序字段</p>
<h3 id="54-springboot自动装配"><a href="#54-springboot自动装配" class="headerlink" title="54. springboot自动装配"></a>54. springboot自动装配</h3><p>所有注解都在做一件事：注册bean到spring容器</p>
<ul>
<li>@springbootConfiguration通过@Bean结合完成Bean的JavaConfig配置；</li>
<li>@ComponentScan通过范围扫描的方式，扫描特定的注解注释类，将其注册到spring容器</li>
<li>@EnableAutoCOnfiguration通过spring.factories的配置，并结合@Condition条件完成bean的注册</li>
<li>@Import通过导入的方式，将指定的class注解解析到pring容器</li>
</ul>
<p>springboot实现自动装配的过程可以分为三步：</p>
<ul>
<li>扫描classpath下的META-INF/spring.factories文件</li>
</ul>
<p>spring.factories文件中定义了各个自动配置类的全限定名。在Spring Boot应用启动时，Spring Boot会自动扫描classpath下的所有spring.factories文件，并将其中的自动配置类加载到应用上下文中。</p>
<ul>
<li>加载自动配置类</li>
</ul>
<p>自动配置类是Spring Boot自动装配的核心，它会根据不同的条件选择不同的装配方案。Spring Boot会根据上一步中扫描到的自动配置类的全限定名来加载这些类，并将它们注册到应用上下文中。</p>
<ul>
<li>根据条件装配Bean</li>
</ul>
<p>当自动配置类加载完成后，Spring Boot会根据自动配置类中定义的条件来确定哪些Bean需要被装配</p>
<h3 id="55-springboot配置文件的加载顺序？"><a href="#55-springboot配置文件的加载顺序？" class="headerlink" title="55. springboot配置文件的加载顺序？"></a>55. springboot配置文件的加载顺序？</h3><ol>
<li>首先会加载项目根目录下的config文件夹中所有的properties或yml文件，按照文件名排序后进行加载</li>
<li>其次会加载项目根目录下的所有properties或yml文件（不包括config文件），按照文件名排序后进行加载</li>
<li>然后会加载classpath下的config问价夹中的所有properties或yml文件</li>
<li>最后加载classpath下所有的properties或yml文件（不包括config文件夹）</li>
</ol>
<p>在加载过程中，后面的配置文件会覆盖前面的配置文件中相同的属性值；</p>
<h3 id="56-springbuffer和stringbuilder的区别"><a href="#56-springbuffer和stringbuilder的区别" class="headerlink" title="56. springbuffer和stringbuilder的区别"></a>56. springbuffer和stringbuilder的区别</h3><p>两者都是可变字符串可以动态的添加和删除字符串内容；</p>
<ul>
<li>stringbuffer是线程安全的，stringbuilder是线程不安全的</li>
<li>stringbuffer的性能低于stringbuilder因为stringbuffer的每个方法都加上了线程同步所以性能较差一点</li>
<li>应用场景：如果需要多线程操作或者需要进行字符串的频繁修改操作，建议使用stringbuffer，而对于单线程使用stringbuilder，因为它的性能更好</li>
</ul>
<h3 id="57-如何解决哈希冲突"><a href="#57-如何解决哈希冲突" class="headerlink" title="57. 如何解决哈希冲突"></a>57. 如何解决哈希冲突</h3><p>开放地址法：按照一定的次序，从哈希表中找到一个空闲的单元，然后把发生冲突的元素存入该单元</p>
<p>链地址法：将哈希值相同的元素构成一个同义词的单链表</p>
<p>再哈希法</p>
<p>建立公共溢出区：哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h3 id="58-mysql索引的缺点"><a href="#58-mysql索引的缺点" class="headerlink" title="58. mysql索引的缺点"></a>58. mysql索引的缺点</h3><ul>
<li>需要占用磁盘空间：索引文件如果太大占用空间也会很大</li>
<li>索引会降低写操作的性能：每次写操作要更新索引，频繁的更新索引，会导致写操作的性能下降</li>
</ul>
<p>（因为索引的前缀查询会使B+数的节点匹配更多的值，增加IO操作、模糊查询的匹配规则，需要对索引列进行字符匹配，匹配效率低会导致性能下降）</p>
<ul>
<li>索引也可能导致查询性能下降，如果索引不当会导致性能下降，如使用前缀查询和模糊查询会导致性能下降</li>
<li>维护索引需要成本 ：需要避免过多的使用索引</li>
</ul>
<h3 id="59-索引的底层实现"><a href="#59-索引的底层实现" class="headerlink" title="59. 索引的底层实现"></a>59. 索引的底层实现</h3><p>B+树和哈希表</p>
<h3 id="60-什么情况下索引会失效"><a href="#60-什么情况下索引会失效" class="headerlink" title="60. 什么情况下索引会失效"></a>60. 什么情况下索引会失效</h3><ol>
<li>对索引进行函数操作，如在where中使用函数操作符</li>
<li>查询中使用了不等式操作符</li>
<li>在索引列上进行隐式转换或者强制类型转换</li>
<li>当查询条件中的列与索引的最左侧前缀不匹配时</li>
<li>当表的数据量非常小</li>
<li>使用了大字段的类型</li>
<li>使用了联合查询，查询条件中使用除索引的第一个字段还是使用了其他字段</li>
<li>使用子查询、临时表、视图</li>
</ol>
<h3 id="61-过滤器和拦截器的区别？"><a href="#61-过滤器和拦截器的区别？" class="headerlink" title="61. 过滤器和拦截器的区别？"></a>61. 过滤器和拦截器的区别？</h3><ol>
<li>触发时机不同：过滤器在请求进入Servlet容器之前拦截请求，而拦截器在请求进入处理器之前或者之后拦截请求。</li>
<li>应用范围不同：过滤器可以在Web.xml文件中进行配置，作用于整个Web应用程序、而拦截器只是对某个特定的处理器进行拦截</li>
<li>接口不同：过滤器实现了javax.servlet.Filter接口，而拦截器实现了Spring框架的HandlerInterceptor接口</li>
<li>共能不同：过滤器是基于Servlet规范实现的可以对请求和响应进行操作，拦截器是SpringMVC框架提供的，对处理器的执行过程进行干预</li>
</ol>
<h3 id="62-Stream流的终止方法有"><a href="#62-Stream流的终止方法有" class="headerlink" title="62.Stream流的终止方法有"></a>62.Stream流的终止方法有</h3><p>stream常用的方法：</p>
<ul>
<li>filter：根据指定的条件过滤</li>
<li>map：将数据转换为新的格式</li>
<li>flatMap：将嵌套的Stream扁平化</li>
<li>sorted：对数据进行排序</li>
<li>distinct：去重</li>
<li>forEach：遍历数据</li>
<li>reduce：将数据集合成一个值</li>
</ul>
<ol>
<li>count：统计个数</li>
<li>collect：将数据收集到一个容器中</li>
<li>toArray：将数据转换为数组</li>
<li>max/min：查找最大值/最小值</li>
<li>findFirst/findAny：查找符合条件的第一个/任意一个数据</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//stream流的倒序排序</span><br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>List&lt;Integer&gt; reversedList = list.stream()<br>    .sorted(Comparator.reverseOrder())<br>    .collect(Collectors.toList());<br></code></pre></td></tr></tbody></table></figure>
<h3 id="63-CountDownLatch的作用，如何使用？"><a href="#63-CountDownLatch的作用，如何使用？" class="headerlink" title="63. CountDownLatch的作用，如何使用？"></a>63. CountDownLatch的作用，如何使用？</h3><p>它可以控制多个线程的执行顺序，作用是让某个线程等待其他线程执行完毕后在执行，它是通过一个计数器实现的，每当一个线程执行完毕后计数器会减一</p>
<ol>
<li>创建countDownLatch对象，初始化计数器的值为需要等待的线程数</li>
<li>在需要等待的线程执行完毕的地方调用CountDownLatch对象的countDown方法，使得计数器减一</li>
</ol>
<h3 id="64-使用explain关键字查询执行计划返回字段？"><a href="#64-使用explain关键字查询执行计划返回字段？" class="headerlink" title="64. 使用explain关键字查询执行计划返回字段？"></a>64. 使用explain关键字查询执行计划返回字段？</h3><ol>
<li>id:查询标识符，判断查询中是否存在子查询以及子查询的执行顺序</li>
<li>select_type：查询类型、简单的查询、联合查询、子查询</li>
<li>table：查询的类型。“all”、index、range、ref</li>
<li>possible_keys：可能用到的索引</li>
<li>key：实际用到的索引</li>
<li>key_len：索引的长度</li>
<li>ref:索引的参考对象</li>
<li>rows：扫描的行数</li>
<li>extra：一些额外的信息</li>
</ol>
<h3 id="65-redis的内存淘汰策略，默认的是哪个，redis的IO多路复用的原理，socket的IO多路复用原理，poll，epoll，select区别"><a href="#65-redis的内存淘汰策略，默认的是哪个，redis的IO多路复用的原理，socket的IO多路复用原理，poll，epoll，select区别" class="headerlink" title="65. redis的内存淘汰策略，默认的是哪个，redis的IO多路复用的原理，socket的IO多路复用原理，poll，epoll，select区别"></a>65. redis的内存淘汰策略，默认的是哪个，redis的IO多路复用的原理，socket的IO多路复用原理，poll，epoll，select区别</h3><ol>
<li>Redis的默认内存淘汰策略是volatile-lru，即从已设置过期时间的键中，选择最近最少使用的键淘汰。</li>
<li>Redis的IO多路复用使用的是单线程的事件驱动模型，其中有一个事件循环负责监听所有socket的读写事件，并调用对应的处理程序。Redis支持多种IO多路复用技术，包括select、poll、epoll，其中select和poll是比较早的技术，epoll是Linux内核2.6版本之后才加入的新技术，相比于select和poll，epoll在处理大量连接时有更好的性能。</li>
<li>Socket的IO多路复用原理：在应用程序中，如果需要同时处理多个socket连接，可以使用IO多路复用技术，避免使用多线程或多进程的方式处理。使用IO多路复用的方式，可以将多个socket注册到一个监听集合中，然后将监听集合交给操作系统的select/poll/epoll系统调用，等待IO事件的发生。当某个socket有数据可读/可写时，IO多路复用会通知应用程序进行处理。</li>
<li>select：最早出现的IO多路复用技术，它通过轮询的方式查询所有注册的socket，发现有数据可读/可写的socket后再进行处理。select有一些缺点，比如对socket数量的限制，每次轮询需要将socket集合从用户空间复制到内核空间等。</li>
<li>poll：在select的基础上进行了优化，它支持更多的socket数量，并且可以避免每次轮询时将socket集合复制到内核空间的操作，但它仍然存在效率</li>
</ol>
<h3 id="66-查询某个进程的端口号"><a href="#66-查询某个进程的端口号" class="headerlink" title="66.查询某个进程的端口号"></a>66.查询某个进程的端口号</h3><ol>
<li>netstat -anp | grep 端口号</li>
<li>ss -ltp |grep 端口号</li>
</ol>
<h3 id="67-spring里面的装饰器是怎么实现的？"><a href="#67-spring里面的装饰器是怎么实现的？" class="headerlink" title="67. spring里面的装饰器是怎么实现的？"></a>67. spring里面的装饰器是怎么实现的？</h3><p>spring框架中的装饰器主要通过AOP实现的，AOP可以通过代理模式实现，在spring中可以使用@AspectJ语法或者基于注解的方式实现AOP。</p>
<h3 id="68-exists和in怎么选？"><a href="#68-exists和in怎么选？" class="headerlink" title="68. exists和in怎么选？"></a>68. exists和in怎么选？</h3><p>两者都是SQL语句数据查询时的选择</p>
<ul>
<li>exists判断某个子查询是否返回了结果、如果返回了结果，则条件成立，exists比in更高效，因为它值判断是否存在而in需要将结果加载到内存在进行比较</li>
<li>当需要查询某个字段是否在另一个表中出现时可以使用in语句，in将某个字段和另一个表中的字段进行比对，如果相同，则符合条件，可以将这个条件作为筛选数据的条件。</li>
</ul>
<h3 id="69-JVM内存模型"><a href="#69-JVM内存模型" class="headerlink" title="69. JVM内存模型"></a>69. JVM内存模型</h3><p>JVM包括线程独占的线程栈、各线程共享堆、方法区、以及直接内存区</p>
<p>堆内存分为：新生代、老年代；新生代内存分为：eden、Survivor 0、Survivor 1三个区域</p>
<p>方法区时各线程共享的内存区域，用于存储类、常量和静态变量也指永久代 JDK8以后替换为元空间</p>
<p>线程私有区：存放线程自己的栈帧，每个栈帧对应一个方法的执行过线程：线程栈还可以分为：本地方法栈和虚拟机栈</p>
<p>直接内存区域：NIO，特点可以减少在java堆和直接内存之间的数据拷贝，提高数据读写效率</p>
<h3 id="70-volatile的作用，volatile如何保证可见性？"><a href="#70-volatile的作用，volatile如何保证可见性？" class="headerlink" title="70.   volatile的作用，volatile如何保证可见性？"></a>70.   volatile的作用，volatile如何保证可见性？</h3><p>volatile主要来修饰变量，它的作用时保证变量的可见性、禁止指令重排和保证原子性。当一个变量被声明为volatile时，它会被存储在主内存中而不是线程的工作内存中、这样其他线程能够立刻看到该变量的变化，因为他们共享一块主内存。</p>
<h3 id="71-动态代理的实现以JDK为例？"><a href="#71-动态代理的实现以JDK为例？" class="headerlink" title="71.动态代理的实现以JDK为例？"></a>71.动态代理的实现以JDK为例？</h3><ol>
<li>定义接口和目标类</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> {<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>;<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"save user"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ol>
<li>实现InvocationHandler接口它是JDK提供的一个接口，他只有一个invok方法，它是代理实例的调用程序</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> {<br>    <span class="hljs-comment">// 目标对象</span><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocationHandler</span><span class="hljs-params">(Object target)</span> {<br>        <span class="hljs-built_in">this</span>.target = target;<br>    }<br><br>    <span class="hljs-comment">// 代理对象调用方法时，会自动调用invoke方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        System.out.println(<span class="hljs-string">"before method"</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">"after method"</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ol>
<li>创建代理对象</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 创建目标对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>        <span class="hljs-comment">// 创建 InvocationHandler 对象</span><br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>(userService);<br><br>        <span class="hljs-comment">// 通过 Proxy.newProxyInstance() 创建代理对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(<br>                userService.getClass().getClassLoader(),<br>                userService.getClass().getInterfaces(),<br>                invocationHandler);<br><br>        <span class="hljs-comment">// 调用代理对象的方法</span><br>        proxy.save();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>创建代理对象调用JDK的静态方法Proxy.newProxyInstance(),该方法会返回一个代理对象传入的两个参数就是代理目标类和目标接口类、InvocationHandler对象</p>
<h3 id="72-流的分类，字符流字节流区别，读取图片用什么流？"><a href="#72-流的分类，字符流字节流区别，读取图片用什么流？" class="headerlink" title="72.流的分类，字符流字节流区别，读取图片用什么流？"></a>72.流的分类，字符流字节流区别，读取图片用什么流？</h3><ol>
<li>字节流：以字节为单位进行操作，主要处理二进制数据，如图片、音频、视频等。字节流的抽象类是InputStream和OutputStream</li>
<li>字符流：以字符为单位主要处理文本数据，如文本文件、字符流的抽象类是Reader和Writer</li>
</ol>
<p>字节流可以处理任何类型的数据，而字符流只能处理文本数据。</p>
<p>当需要读取或写入图片等二进制文件时，应该使用字节流，即InputStream和OutputStream</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://7756jokerqaq.github.io">LiYiChen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://7756jokerqaq.github.io/2023/02/27/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/mainshi/">https://7756jokerqaq.github.io/2023/02/27/后端学习/mainshi/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://7756jokerqaq.github.io" target="_blank">JokerQAQ的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/27/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Zookeeper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"><img class="prev-cover" src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/hellopicture.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Zookeeper的基本使用</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/Leecode%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"><img class="next-cover" src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/asd123324.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeeCode</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/" title="面试题2"><img class="cover" src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">面试题2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/wallhaven-4y6170_1920x1080.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LiYiChen</div><div class="author-info__description">日常学习记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/7756JokerQAQ"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/7756JokerQAQ" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2677006173@qq.com" target="_blank" title="QQ邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://7756jokerqaq.github.io" target="_blank" title="博客"><i class="fa-brands fa-blogger"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">日常学习java后端和前端</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%A7%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94"><span class="toc-number">1.</span> <span class="toc-text">面试题性的总结与回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.  Java 常用的集合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.   集合之间有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">3.集合之间有什么转换关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Stream%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. Stream流的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. 多线程的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. 什么时候用到多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.7.</span> <span class="toc-text">7.线程怎么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-run%E6%96%B9%E6%B3%95%E5%92%8Cstart%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.8.</span> <span class="toc-text">8. run方法和start方法有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%B0%88%E8%B0%88%E5%AF%B9spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.9.</span> <span class="toc-text">9.谈谈对spring的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-spring-%E7%9A%84-bean-%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.10.</span> <span class="toc-text">10. spring 的 bean 是什么时候初始化的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-spring%E7%9A%84bean%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B%E7%9A%84"><span class="toc-number">1.0.11.</span> <span class="toc-text">11. spring的bean默认是单例还是多例的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.0.12.</span> <span class="toc-text">12. 对事务的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-java%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.0.13.</span> <span class="toc-text">13. java中事务的回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD-controller%E5%B1%82%E6%8E%A5%E6%94%B6%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.0.14.</span> <span class="toc-text">14. springboot项目中 controller层接收前端的参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.0.15.</span> <span class="toc-text">15. SpringMVC执行流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB"><span class="toc-number">1.0.16.</span> <span class="toc-text">16. 如何理解前后端分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-mybatis%E5%92%8Cmybatisplus%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.17.</span> <span class="toc-text">17. mybatis和mybatisplus的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-mp%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%80%8E%E4%B9%88%E5%81%9A%E6%AF%94%E8%BE%83%E5%A4%9A%EF%BC%9F"><span class="toc-number">1.0.18.</span> <span class="toc-text">18. mp的查询怎么做比较多？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-mp%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%A4%9A%E8%A1%A8%E7%9A%84%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.19.</span> <span class="toc-text">19.  mp可以做多表的联合查询吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.0.20.</span> <span class="toc-text">20. 对索引的理解？什么情况下需要建立索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.21.</span> <span class="toc-text">21. 慢查询指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%8D%95%E5%8F%A5sql%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.0.22.</span> <span class="toc-text">22. 单句sql如何判断是否走了索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">1.0.23.</span> <span class="toc-text">23.数据库的锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E9%94%81%E5%92%8C%E9%94%81%E7%9A%84%E5%86%B2%E7%AA%81%E9%80%9A%E5%B8%B8%E5%8F%91%E7%94%9F%E5%9C%A8%EF%BC%9F"><span class="toc-number">1.0.24.</span> <span class="toc-text">24. 锁和锁的冲突通常发生在？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.25.</span> <span class="toc-text">25.后端接口性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9FRedis%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">1.0.26.</span> <span class="toc-text">26. 什么时候用缓存？Redis是什么数据库？数据存储在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-java%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0%E5%9C%A8%E9%82%A3%E4%B8%80%E5%B1%82"><span class="toc-number">1.0.27.</span> <span class="toc-text">27. java的业务逻辑实现在那一层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-service%E5%B1%82%E7%9A%84%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%8E%BB%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%86%99%E4%BC%9A%E6%9C%89%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.0.28.</span> <span class="toc-text">28. service层的代码怎么去优化，什么方式去写会有性能问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-mysql%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.29.</span> <span class="toc-text">29. mysql数据量大怎么进行优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-git%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E5%86%B2%E7%AA%81"><span class="toc-number">1.0.30.</span> <span class="toc-text">30. git提交代码出现冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-git%E5%92%8CSDK%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.31.</span> <span class="toc-text">31. git和SDK的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-git%E7%9A%84%E5%88%86%E6%94%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.32.</span> <span class="toc-text">32. git的分支什么时候用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-springboot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.33.</span> <span class="toc-text">33. springboot的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84session%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.34.</span> <span class="toc-text">34. Redis如何实现分布式的session的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%EF%BC%9F"><span class="toc-number">1.0.35.</span> <span class="toc-text">35. 缓存预热？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.0.36.</span> <span class="toc-text">36. 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.0.37.</span> <span class="toc-text">37. 分布式锁的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4%EF%BC%9F%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%94%B9%E6%88%90%E9%9B%86%E7%BE%A4%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.38.</span> <span class="toc-text">38. 什么是集群？一个项目改成集群需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-mybatis-plus%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.39.</span> <span class="toc-text">39. mybatis-plus执行流程工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-JDK8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.40.</span> <span class="toc-text">40. JDK8的新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.41.</span> <span class="toc-text">41. git常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.42.</span> <span class="toc-text">42. Linux的常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-Nginx%E7%AE%80%E4%BB%8B"><span class="toc-number">1.0.43.</span> <span class="toc-text">43. Nginx简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%8A%80%E6%9C%AF"><span class="toc-number">1.0.44.</span> <span class="toc-text">44. 多线程常见的概念和技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-java%E9%87%8C%E9%9D%A2%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%88%86%E5%87%A0%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.0.45.</span> <span class="toc-text">45. java里面的垃圾回收分几类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.0.46.</span> <span class="toc-text">46. 线程的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Array%E5%92%8CArrayList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.47.</span> <span class="toc-text">47. Array和ArrayList的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E8%AF%B7%E8%AF%B4%E8%AF%B4Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.48.</span> <span class="toc-text">48. 请说说Redis的持久化机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E9%A1%B9%E7%9B%AE%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86redis-%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.49.</span> <span class="toc-text">49. 项目哪里用到了redis 怎么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.50.</span> <span class="toc-text">50. InnoDB和MyISAM的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.0.51.</span> <span class="toc-text">51. 线程的创建方式有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-hashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.52.</span> <span class="toc-text">52.hashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.53.</span> <span class="toc-text">53. #和$的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">1.0.54.</span> <span class="toc-text">54. springboot自动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">1.0.55.</span> <span class="toc-text">55. springboot配置文件的加载顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-springbuffer%E5%92%8Cstringbuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.56.</span> <span class="toc-text">56. springbuffer和stringbuilder的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.0.57.</span> <span class="toc-text">57. 如何解决哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.0.58.</span> <span class="toc-text">58. mysql索引的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.59.</span> <span class="toc-text">59. 索引的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">1.0.60.</span> <span class="toc-text">60. 什么情况下索引会失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.61.</span> <span class="toc-text">61. 过滤器和拦截器的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-Stream%E6%B5%81%E7%9A%84%E7%BB%88%E6%AD%A2%E6%96%B9%E6%B3%95%E6%9C%89"><span class="toc-number">1.0.62.</span> <span class="toc-text">62.Stream流的终止方法有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-CountDownLatch%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.63.</span> <span class="toc-text">63. CountDownLatch的作用，如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%BF%94%E5%9B%9E%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">1.0.64.</span> <span class="toc-text">64. 使用explain关键字查询执行计划返回字段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%8Credis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8Csocket%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%8Cpoll%EF%BC%8Cepoll%EF%BC%8Cselect%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.65.</span> <span class="toc-text">65. redis的内存淘汰策略，默认的是哪个，redis的IO多路复用的原理，socket的IO多路复用原理，poll，epoll，select区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">1.0.66.</span> <span class="toc-text">66.查询某个进程的端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-spring%E9%87%8C%E9%9D%A2%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.67.</span> <span class="toc-text">67. spring里面的装饰器是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-exists%E5%92%8Cin%E6%80%8E%E4%B9%88%E9%80%89%EF%BC%9F"><span class="toc-number">1.0.68.</span> <span class="toc-text">68. exists和in怎么选？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.69.</span> <span class="toc-text">69. JVM内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-volatile%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8Cvolatile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.70.</span> <span class="toc-text">70.   volatile的作用，volatile如何保证可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5JDK%E4%B8%BA%E4%BE%8B%EF%BC%9F"><span class="toc-number">1.0.71.</span> <span class="toc-text">71.动态代理的实现以JDK为例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%B5%81%EF%BC%9F"><span class="toc-number">1.0.72.</span> <span class="toc-text">72.流的分类，字符流字节流区别，读取图片用什么流？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/05/%E5%B7%A5%E5%85%B7%E7%B1%BB/tools/" title="Java常见工具类"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/hellopicture.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java常见工具类"/></a><div class="content"><a class="title" href="/2023/04/05/%E5%B7%A5%E5%85%B7%E7%B1%BB/tools/" title="Java常见工具类">Java常见工具类</a><time datetime="2023-04-04T16:00:00.000Z" title="发表于 2023-04-05 00:00:00">2023-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/03/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/SpringSecurity/" title="SpringSecurity学习"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/wallhaven-576ry7_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity学习"/></a><div class="content"><a class="title" href="/2023/04/03/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/SpringSecurity/" title="SpringSecurity学习">SpringSecurity学习</a><time datetime="2023-04-02T16:00:00.000Z" title="发表于 2023-04-03 00:00:00">2023-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/28/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/2035%E8%A7%84%E5%88%92/" title="2035规划学习"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/cccc.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2035规划学习"/></a><div class="content"><a class="title" href="/2023/03/28/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/2035%E8%A7%84%E5%88%92/" title="2035规划学习">2035规划学习</a><time datetime="2023-03-27T16:00:00.000Z" title="发表于 2023-03-28 00:00:00">2023-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%8D%95%E8%B0%83%E6%A0%88and%E4%BA%8C%E5%8F%89%E6%A0%91/" title="单调栈和二叉树"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303211444122.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单调栈和二叉树"/></a><div class="content"><a class="title" href="/2023/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%8D%95%E8%B0%83%E6%A0%88and%E4%BA%8C%E5%8F%89%E6%A0%91/" title="单调栈和二叉树">单调栈和二叉树</a><time datetime="2023-03-20T16:00:00.000Z" title="发表于 2023-03-21 00:00:00">2023-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Eureka%E5%92%8CRibbon/" title="Eureka And Ribbon"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Eureka And Ribbon"/></a><div class="content"><a class="title" href="/2023/03/19/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Eureka%E5%92%8CRibbon/" title="Eureka And Ribbon">Eureka And Ribbon</a><time datetime="2023-03-18T16:00:00.000Z" title="发表于 2023-03-19 00:00:00">2023-03-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By LiYiChen</div><div class="footer_custom_text">Hi,welcome to my <a href="https://7756jokerqaq.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="ftrue"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>