<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>LeeCode | JokerQAQ的博客</title><meta name="keywords" content="力扣&amp;刷题"><meta name="author" content="LiYiChen"><meta name="copyright" content="LiYiChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习！">
<meta property="og:type" content="article">
<meta property="og:title" content="LeeCode">
<meta property="og:url" content="https://7756jokerqaq.github.io/2022/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/Leecode%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="JokerQAQ的博客">
<meta property="og:description" content="学习！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png">
<meta property="article:published_time" content="2022-03-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-19T08:10:40.819Z">
<meta property="article:author" content="LiYiChen">
<meta property="article:tag" content="力扣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/7756JokerQAQ/picodemoo/main/img/WebImg.png"><link rel="canonical" href="https://7756jokerqaq.github.io/2022/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/Leecode%E5%88%B7%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: LiYiChen","link":"链接: ","source":"来源: JokerQAQ的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeeCode',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-19 16:10:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/duotone.css"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/wallhaven-4y6170_1920x1080.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JokerQAQ的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeeCode</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-10T16:00:00.000Z" title="发表于 2022-03-11 00:00:00">2022-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-19T08:10:40.819Z" title="更新于 2023-03-19 16:10:40">2023-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">671</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>2分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeeCode"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Leecode刷题"><a href="#Leecode刷题" class="headerlink" title="Leecode刷题"></a>Leecode刷题</h1><ol>
<li>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</li>
</ol>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303131403806.jpeg" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>思路分析</strong>:对于该情况我们可以使用双指针的思想来进行求解，首先我们定义两个指针分别指向两侧，就如第0根和第8根然后得出当前的容量大小为1<em>8=8，因为两根柱子的最低高度为1，选最低的进行计算，下来我们继续分析这种情况因为要求解最大容量，为了前进必须排除柱子，我们从两根最低的柱子进行排除，第0根柱子高度为1，想一下如果第0根柱子匹配到1~7根柱子的时候，它的宽度再降低，而他的<strong>最终计算的高度（两根柱子的最小值）</strong>绝对不会超过当前<strong>第0根柱子</strong>所以当前的容量就是第0根柱子参与所能得到的最大容量，所以我们就可以<strong>记录当前的容量</strong>，接着<em>*排除第0根柱子</em></em>。</p>
<p>   当第0根柱子排除以后，定义的双指针假设i为左指针j为右指针，排除0后i++,j还是等于8，此时容器的区间为1~8，计算其容量为7<em>7=49，最小的柱子为第8根，接着我们继续想下去，和第8根进行匹配的柱子是不是当前的容量是最大的，<em>*不相信？</em></em><span class="github-emoji"><span>🤣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f923.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 你接着拿第 2~7根柱子分析一波，你会惊奇的发现，咦？<span class="github-emoji"><span>😳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f633.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 它的宽度逐渐降低，然而它的最高的高度也不会超过第8根柱子，哈哈哈奇妙吧！所以当前的容量记录的就是第8根柱子能达到的最大容量，然后更新当前的容量值，继续拿下一个柱子开刀，当然是要从你当前记录的那个柱子开始了，如果柱子在左边i++，柱子在右侧j—;所以思路就很明确啦：</p>
<ol>
<li>定义两个指针i,j分别指向0和len-1，接着定义一个最大容量maxCup;<span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li>一个循环只有当符合i<j是循环继续嘿嘿<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></j是循环继续嘿嘿<span></li>
<li>在内测首先需要得到当前的容量简单的计算(j-i)*(最小的高度minHeight(i,j))，计算后更新最大值</li>
<li>然后容器的宽度开始收缩，如果height[i]&lt;height[j]说明右边不动，左边收缩哈哈哈，很nice反之就右边收缩，如果两者相等，收缩那边都可以这样就解决了。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> {<br>    	<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    	<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    	<span class="hljs-type">int</span> j=height.length-<span class="hljs-number">1</span>;<br>    	<span class="hljs-keyword">while</span> (i&lt;j){<br>    		<span class="hljs-type">int</span> area=(j-i)*Math.min(height[i],height[j]);<br>    		res=Math.max(area,res);<br>    		<span class="hljs-keyword">if</span> (height[i]&lt;height[j]){<br>    			i++;<br>			}<span class="hljs-keyword">else</span> {<br>    			j--;<br>			}<br>		}<br>    	<span class="hljs-keyword">return</span> res;<br>    }<br>}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>15.给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>如果需要进行搜寻三数之和先来瞅瞅大主线的方向</p>
<ul>
<li>先对nums数组进行排序（从小到大进行排序）</li>
<li>固定一个值，来进行两数之和的求值</li>
<li>去除重复的数组元素</li>
</ul>
<p>所以下来分析就可以很容易得知道一个好的解题思路就上来了<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>首先对数组排序会把，一个sort函数，其次开始进行一个元素得固定，简单一个while循环，从i=0开始到数组得长度减去2为止（切记不能直接遍历到最后一位了，也就是最起码你得留一个三元组在里吧<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>也就是到倒数第三个元素就得刹车 ！）</p>
<p>举个<span class="github-emoji"><span>🌟</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>数组[-4,-1,-1,-1,0,1,2]首先我们固定第一个元素也就是-4，然后简化三数之和为两数之和，可以用两个指针一个指向-1一个指向2，然后我们进行一个遍历求和操作，每次操作只要把-4带上就行<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>就好比他是一个已经知道得元素，你这样看首先是-1+2-4=-3&lt;0，所以我们直接考虑将左指针向前移动一位发现还是-1-4+2=-3，不着急接着左移-4+2+0=-2，接着左移直到移到最后一位得时候发现，咦?<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>竟然全是小于0得数字，所以结果是找不到，从开始加到现在我们发现一个很有趣得现象，就是所有的结果全部都小于零所以当前你固定的第一个数-4是无效的 <span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>所以咱就固定第二个数吧，不着急第二个数字是-1，接着按照上述的步骤，我们可以快乐的发现-1-1+2=0咦<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>春天来了，找到一个，然后很简单直接加入就行，加入后你会发现一个问题，再次循环操作一番后发现三个-1连拍出现了结果[-1,-1,2]出现了两次，所以是不是想到了去重<span class="github-emoji"><span>😸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f638.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>很简单，因为这个数组是有序的能想同，说明这个数字重复的出现了，所以记录当前重复的数(可不是固定的数字熬就比如固定数字-1重复数字-2那就记录-2)然后让指针进行++进行一个偏移间接的去除重复元组.</p>
<p>最后呢，你以为完了，nonono还有呢当你返回到固定的数字，有没有考虑到，固定的数字也能重复，又是一个大坑，所以在固定数字的地方也进行一个重复去重，最后结果就出来了;代码如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>       <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>           <span class="hljs-comment">//固定一个值然后进行转化，求解两数之和的问题</span><br>           <span class="hljs-comment">//需要去除重复的三元组</span><br>           Arrays.sort(nums);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = nums.length;<br>           List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           <span class="hljs-comment">//此处的i从最左边开始不会到达最右边</span><br>           <span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">2</span>) {<br>               TwoSum(i, nums, res);<br>               <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>               <span class="hljs-comment">//接着去除重复的元素</span><br>               <span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">2</span> &amp;&amp; nums[i] == temp) {<br>                   i++;<br>               }<br>           }<br>           <span class="hljs-keyword">return</span> res;<br>       }<br><br>       <span class="hljs-comment">//-4 -1 -1 0 1 2</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TwoSum</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res)</span> {<br>           <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>           <span class="hljs-comment">//这里是吧i给固定了所以只需要求解p1和p2之和就可以了</span><br>           <span class="hljs-keyword">while</span> (p1 &lt; p2) {<br>               <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[p1] + nums[p2] + nums[i];<br>               <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>) {<br>                   p2--;<br>               } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>) {<br>                   p1++;<br>               } <span class="hljs-keyword">else</span> {<br>                   List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                   list.add(nums[p1]);<br>                   list.add(nums[p2]);<br>                   list.add(nums[i]);<br>                   res.add(list);<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> nums[p1];<br>                   <span class="hljs-comment">//需要除去重复的三元组</span><br>                   <span class="hljs-keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == temp1) {<br>                       p1++;<br>                   }<br>               }<br>           }<br><br>       }<br>   }<br></code></pre></td></tr></tbody></table></figure>
<p>17.给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303132137796.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：digits = "23"<br>输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：digits = ""<br>输出：[]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：digits = "2"<br>输出：["a","b","c"]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>本题的主要方式是递归回溯算法：具体的解题我们首先想到的肯定是打表<span class="github-emoji"><span>😸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f638.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不会这个都想不到吧<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>所以根据得到的数字可以进行计算了，根据示例想到的是什么？没错就是笛卡尔积，这玩意如果你拆开一个一个的乘，累不死人才怪，所以我们只能另辟蹊径来解题了。这次比较机制的是将结果定义成私有变量，少了一个传参的必要<span class="github-emoji"><span>😙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f619.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>同时也定义一个私有的StringBuilder来进行字符串的<strong>拼接</strong>，拼接？对没错就是拼接嘿嘿，看看这个<strong>骚操作</strong>吧！递归的进行:happy:递归的函数也挺简单的呃只需要一个String和StringBuilder以及一个index（这玩意用于删除用的）方便的递归.</p>
<p>下面递归的开始:未开始先考虑结束的情况<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>什么情况结束呢？首先就是传入的字符串的长度为0不用说直接返回，还有一种就是当前传入的index的大小正好为字符串的长度<span class="github-emoji"><span>😸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f638.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>想到了什么<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>没错笛卡尔积的结果，如果digital为两位数那么它的笛卡尔积结果每一项都是两位数，所以你想什么呢?直接存到结果中呀！，当然这是最后递归的结果，下面开始叙述逻辑了：开车开始，简单每个循环首先得到的肯定是当前的index对应的字符串，然后就进行一个字符串长度的遍历，重要的来了！<strong>重要的来了！</strong> 在循环里面，首先就是对sb进行续接，接上后就要递归进去了然后如果还有的话就继续递归进去，那是否你有个问题就是sb会越来越长！<strong>聪明</strong>， 不过别急还有后招呢，在递归结束的最后我们需要把每次我们添加的元素在删除了，这不就没了吗<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>惊不惊喜意不意外<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>所以总体来说就是加一个删除一个，哈哈哈看看具体的实例过程你就明白了.</p>
<p>比如两个字符串笛卡尔积  abc、efg：</p>
<ul>
<li>首先取出a接入sb中,接着递归进去就到了efg接着再取出e接续到a的后面，当再递归进去的时候会发现str=index所以这个ef就添加到了结果中，接着回溯到上一级就是刚刚把e添加再尾部,接着咱再把这个e个去除了，在一个for循环中接着开始对f进行拼接<span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li>当a和efg逐个拼接完成后，再递归出最外层，将a给删除了下来就进行b的递归<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li>然后就直接输出结果就行了</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>       <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-comment">//首先进行打表</span><br>       String digitsMap[] = {<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>};<br>       List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//进行字符串拼接的方法</span><br>       <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>       <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> {<br>           combination(digits, stringBuilder, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">return</span> res;<br>       }<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">combination</span><span class="hljs-params">(String str, StringBuilder sb, <span class="hljs-type">int</span> index)</span> {<br>           <span class="hljs-keyword">if</span> (str.length() == <span class="hljs-number">0</span>) {<br>               <span class="hljs-keyword">return</span>;<br>           }<br>           <span class="hljs-keyword">if</span> (index == str.length()) {<br>               res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb));<br>               <span class="hljs-keyword">return</span>;<br>           }<br>           <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(index);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">'0'</span>;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">currentStr</span> <span class="hljs-operator">=</span> digitsMap[pos];<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; currentStr.length(); i++) {<br>               sb.append(currentStr.charAt(i));<br>               <span class="hljs-comment">//深入递归算法</span><br>               combination(str, sb, index + <span class="hljs-number">1</span>);<br>               sb.deleteCharAt(index);<br>           }<br>       }<br>   }<br></code></pre></td></tr></tbody></table></figure>
<p>21.将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303132313967.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：l1 = [], l2 = []<br>输出：[]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：l1 = [], l2 = [0]<br>输出：[0]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>本题说难的话特别难，说简单的话特别简单，只要有一个递归的思想<span class="github-emoji"><span>😺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>啥都不是事，老老实实的开始开车讲解：</p>
<p>这就是一个简单的双链表进行合并，根据题目可以知道如果list1为空返回list2，反之则返回list1，所以一切貌似变得简单了起来，我们以两个链表来看,如果list1的值小于list2的值则对list1链表来进行操作，让list1的下一个指向另外两个链表的合并，如果list1的值大于等于list2则让list2的下一个指向另外两个链表的合并，这里我也说的模模糊糊的大概就是这个意思递归的加入链表，每次都加入最小的值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> {<br><span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>){<br>	<span class="hljs-keyword">return</span> list2;<br>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>){<br>	<span class="hljs-keyword">return</span> list1;<br>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.val&lt; list2.val){<br>	list1.next=mergeTwoLists(list1.next,list2);<br>	<span class="hljs-keyword">return</span> list1;<br>}<span class="hljs-keyword">else</span> {<br>	list2.next=mergeTwoLists(list1,list2.next);<br>	<span class="hljs-keyword">return</span> list2;<br>}<br>   }<br></code></pre></td></tr></tbody></table></figure>
<p>22.括号的生成</p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 3<br>输出：["((()))","(()())","(())()","()(())","()()()"]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 1<br>输出：["()"]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303140839555.png" alt="树的分类"></p>
<p><strong>解题思路：</strong></p>
<p>其实这道题也非常的简单<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>就如上面的图清晰明白吧，很好的想法，给你数字n，那么右侧左侧全有n个，我们画出关键的树<span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>,然后就得到了上述图，我们会惊奇的发现<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>竟然还有截肢，当然当左括号的数目小于右括号，无论你怎么加都符合不了，对吧？<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后下来就好整了,其中有一个就是<strong>截肢</strong>，对于符合的我们先递归的进行首先对左子树一路递归到底，每次left-1，然后<strong>str上面进行加上’(‘</strong>,忘了忘了，<strong>咱们递归先考虑的是啥？？</strong><span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>当然是递归结束，<span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>所以呢，结束的标志是什么？当然是left=right=0了，根据上图就能看出，所以咱们的递归的参数就有4个第一个是每次进行加括号的str第二第三个是left和right的数值也就是n，最后一个别想了就是存结果的List<span class="github-emoji"><span>😪</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>,那么想法就非常简单了，就往死里递归就行了，当两个都等于0直接加入结果退出循环，反之如果left&gt;0就调用递归函数，一直递归到left=0，接着再调用right&gt;0的部分直至递归到left也=0,<span class="github-emoji"><span>😚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后结果就出来了.如下所示:</p>
<p>kao!突然忘了还有截肢呢，就是在递归的途中如果发现，left&gt;right直接return不用想违规了<span class="github-emoji"><span>😪</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>就这样！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>	<span class="hljs-comment">//可以考虑深度优先遍历</span><br><br>		ArrayList&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>		<span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>){<br>			<span class="hljs-keyword">return</span> result;<br>		}<br>		dfs(<span class="hljs-string">""</span>,n,n,result);<br>		<span class="hljs-keyword">return</span> result;<br>	}<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String curStr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,List&lt;String&gt;res)</span>{<br>    	<span class="hljs-keyword">if</span> (left==<span class="hljs-number">0</span>&amp;&amp;right==<span class="hljs-number">0</span>){<br>    		res.add(curStr);<br><br>    		<span class="hljs-keyword">return</span>;<br>		}<br>    	<span class="hljs-comment">//需要删除不需要当左侧剩余大于右侧也就是不满足了括号的匹配法则</span><br>    	<span class="hljs-keyword">if</span> (left&gt;right){<br>    		<span class="hljs-keyword">return</span>;<br>		}<br>        <span class="hljs-comment">//往左子树死里递归</span><br>    	<span class="hljs-keyword">if</span> (left&gt;<span class="hljs-number">0</span>){<br>    		dfs(curStr+<span class="hljs-string">"("</span>,left-<span class="hljs-number">1</span>,right,res);<br>		}<br>        <span class="hljs-comment">//右子树死里递归</span><br>    	<span class="hljs-keyword">if</span> (right&gt;<span class="hljs-number">0</span>){<br>    		dfs(curStr+<span class="hljs-string">")"</span>,left,right-<span class="hljs-number">1</span>,res);<br>		}<br>	}<br></code></pre></td></tr></tbody></table></figure>
<p>31.整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法"> 原地 </a></strong>修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,2,3]<br>输出：[1,3,2]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,2,1]<br>输出：[1,2,3]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,1,5]<br>输出：[1,5,1]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><strong>题解思路：</strong></p>
<p>本题吧，我是没有做出来，但是答案是看懂了，它说的这么多就是一个意思，给你一个当前的数字，你给我找出来，这些数字随机组合后并进行排序后，当前数字的下一个最大的数字，等等<span class="github-emoji"><span>😧</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f627.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>你不会真的将他们随机组合加排序吧！！！这样能累死人的好吧，咱们想一个好的方法不香吗？按照我的思路来，竟然是要照一个比他大一丢丢的数字，很简单了，咱们就改动最小，让其增加的最多就好了，关键点了<strong>敲黑板</strong><span class="github-emoji"><span>😈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f608.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>咱们从最后的一个数字开始进行查找，当然如果要交换准确的是重倒数第二个数字开始：<span class="github-emoji"><span>😗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f617.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后我们找到当前的数字小于它的下一个数字的下标，这个玩意是为了确保i的位置，以及预防一种情况就是，当这个数字正好是从小到大排的，如果不这样的话到最后直接G,所以找到当前的i值后说明i~n-1一定有一个数是他小于的，接着咱找需要交换的数字，再次循环，根据得到的i找到第一个<code>nums[j]&gt;nums[i]</code>的值<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>找到后不用想定位j，直接对i，j位置的元素进行交换，你以为这样就完了？？想的太美好了就例如 231你找到了i=0,j=1也就是2和3进行交换结果321完美！呼死你<span class="github-emoji"><span>😇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f607.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>你把我312吃了，我比你更接近好吧，所以别心急，还需要对i之后的元素进行一个排序这样就完美的解决了问题!!</p>
<ul>
<li>从后往前找到第一个（最大索引）比自己后一位小的元素，确定i的位置</li>
<li>从后往前找第一个比nums[i]大的元素下标为j，交换两个位置的元素</li>
<li>翻转i+1到n-1的元素,得到下一个序列</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>          <span class="hljs-comment">//153162 i要找到最小的，j要找到刚刚大于i一点点的</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>          <span class="hljs-comment">//找到对应得i值</span><br>          <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) {<br>              i--;<br>          }<br>          <span class="hljs-comment">//找到j得值。前提是i&gt;0如果不大于零说明啥？从该序列从大到小得排序，直接反转序列就行了，还管啥j得事情</span><br>          <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) {<br>              <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>              <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) {<br>                  j--;<br>              }<br>              swap(nums, i, j);<br>          }<br>          reverse(nums, i + <span class="hljs-number">1</span>);<br>      }<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {<br>          <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>          nums[j] = nums[i];<br>          nums[i] = temp;<br>      }<br>      <span class="hljs-comment">//提高算法得效率这个i之后得序列是有规律的直接对齐进行高低位的交换就行了</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> {<br>          <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">while</span> (left &lt; right) {<br>              swap(nums, left, right);<br>              left++;<br>              right--;<br>          }<br>      }<br>  }<br></code></pre></td></tr></tbody></table></figure>
<p>39.给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: candidates = [2], target = 1<br>输出: []<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>看到这道题是不是有种似曾相识的感觉？<span class="github-emoji"><span>😇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f607.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>！没有？扇给你两个八张，回溯呀！多么容易就能看出的感觉，你看看这target每次减少它一点然后再递归递归完成后再加载过来不就行了蛮,所以蛮具体思路清晰了，我们开始来讨论参数了，简单回溯的参数这个还确实有点多，让人头大<span class="github-emoji"><span>😈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f608.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不过没关系慢慢的分析就简洁明了了，首先那个candidates肯定是需要的，我们还需要个啥？回溯！肯定是遍历的起始和结束整数啦，然后还需要一个能存储结果集的List<list<interger>&gt;最后需要一个栈呀来依次存放添加的元素也可以使用链表都可以无伤大雅<span class="github-emoji"><span>😯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后一切准备就绪就开始递归遍历啦！？？？<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>你是否忘掉了啥！没错递归结束的条件呀，真笨，这都不写，你想一辈子递归下去？所以简单的分析一波，递归的结束无非两种，一种就是没有找到对应的数组，直接返回，另一种是有结果了，就添加到res中就行了<span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>所以呢，你就直接添加呀res.add(new ArrayList(stack))这就默认直接转换了这不就直接添加了。</list<interger></p>
<p>接着就需要了解小回溯的部分了，他每次都得到当前的candidates的值先加入stack中然后让target减去该值接着放入到递归中，当最后的结果完成了还需要回溯呢，需要将它的值再加回来而且也要移除stack的最后一位元素，这样回溯就完成了代码如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> {<br>	<span class="hljs-comment">//一个回溯的算法很容易思考的</span><br>		<span class="hljs-type">int</span> len=candidates.length;<br>		List&lt;List&lt;Integer&gt;&gt;res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>		<span class="hljs-keyword">if</span> (len==<span class="hljs-number">0</span>){<br>			<span class="hljs-keyword">return</span> res;<br>		}<br>		Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>		dfs(candidates,<span class="hljs-number">0</span>,len,res,stack,target);<br>		<span class="hljs-keyword">return</span>  res;<br>	}<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []candidates,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> len,List&lt;List&lt;Integer&gt;&gt;res,Deque&lt;Integer&gt; stack,<span class="hljs-type">int</span> target)</span>{<br>		<span class="hljs-keyword">if</span> (target&lt;<span class="hljs-number">0</span>){<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-keyword">if</span> (target==<span class="hljs-number">0</span>){<br>			res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stack));<br>			<span class="hljs-keyword">return</span>;<br>		}<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=begin;i&lt;len;i++){<br>			stack.addLast(candidates[i]);<br>			target-=candidates[i];<br>			dfs(candidates,i,len,res,stack,target);<br>			stack.removeLast();<br>			target+=candidates[i];<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>46.给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [0,1]<br>输出：[[0,1],[1,0]]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1]<br>输出：[[1]]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p><strong>思路题解：</strong></p>
<p>真是服了有一次没做出来<span class="github-emoji"><span>😰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>咋变了个样子有忘了原先的套路了呢，这次要好好的想想了，真是看了题解才一切都明了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>多么秒的解法呀！自己解的时候关键的点在于那个不重复的数字的数组，所以自己搞得一大度111,222,112这个不重复没有解决哎~<span class="github-emoji"><span>😬</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不过这次有进步，懂得了需要不重复可以创建一个boolean数组来记录当前的数组是否使用过了就可以了蛮，所以一切👉回归了原始：<span class="github-emoji"><span>👽</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f47d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>递归的遍历有深度(depth)和是否使用过 (used)以及当前的数组结果和长度,先考虑结束的情况就是当len=depth是进行加入结果操作，对于回溯部分，我们可以每次从0开始遍历到某个数字加入到预先定义的栈中，并且将当前的used设置为true接着调用dfs调用完后再将used设置为false就可以了代码如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>	<span class="hljs-type">int</span> len=nums.length;<br>	List&lt;List&lt;Integer&gt;&gt;res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>		Deque&lt;Integer&gt;stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>		<span class="hljs-type">boolean</span> used[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len];<br>		dfs(nums,<span class="hljs-number">0</span>,len,res,stack,used);<br>    	<span class="hljs-keyword">return</span> res;<br>    }<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> depth,<span class="hljs-type">int</span> len,List&lt;List&lt;Integer&gt;&gt;res,Deque&lt;Integer&gt;stack,<span class="hljs-type">boolean</span>[] used)</span>{<br>    	<span class="hljs-keyword">if</span> (depth==len){<br>    		res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stack));<br>    		<span class="hljs-keyword">return</span>;<br>		}<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){<br>    		<span class="hljs-keyword">if</span> (used[i]){<br>    			<span class="hljs-keyword">continue</span>;<br>			}<br>    		stack.addLast(nums[i]);<br>    		used[i]=<span class="hljs-literal">true</span>;<br>    		dfs(nums,depth+<span class="hljs-number">1</span>,len,res,stack,used);<br>    		stack.removeLast();<br>    		used[i]=<span class="hljs-literal">false</span>;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>55.给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>解题思路：</strong>可以利用贪心来进行操作，每次得到的次数都进行一个比较更新它能跳的最远的值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>    	<span class="hljs-comment">//解题思路直接每一步都进行跳跃就可以了,每次记录他能跳跃的最远距离</span><br>		<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++){<br>            <span class="hljs-comment">//判断是否能够到达当i&gt;k的时候就说明接下来无论如何都不会在进行前进了</span><br>            <span class="hljs-keyword">if</span>(i&gt;k)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//(i+nums[i])这个可以求出每一项元素能跳的最远距离与当前能跳的最远距离进行比较，如果大于就更新，反之就保持原本的不变</span><br>            k=Math.max(k,i+nums[i])<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>62.一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303142002569.png" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：m = 3, n = 7<br>输出：28<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。<br>1. 向右 -&gt; 向下 -&gt; 向下<br>2. 向下 -&gt; 向下 -&gt; 向右<br>3. 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<p><strong>题解思路：</strong></p>
<p>根据题目我们很容的知道这道题是个动态规划问题，哎又是不会的一道，感觉思想貌似扭住了，看了题解顿时恍然大悟。。。<span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>其实动态规划很简单的意思就是考虑部分，就拿机器人来说，最简单的考虑就是从start-finish的路径最简单的理解就是从 m+n-2步中挑出下移的步骤也就是m-1总体来说就是C(m-1,m+n-2)的二项公式<span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后呢我们要以代码的思维来解决这道题，就拿任意一个点我们很容易知道它的来源路径dp[i-1][j]或者dp[i][j-1]也就是dp[i][j]=dp[i-1][j]+dp[i][j-1],所以根据这个公式一切都变得简单了我们从头开始走每次经历下一个都会将dp中下一个数字进行更新，直至全部的dp表更新完成就行，每个dp[i][j]内容都是从开始到达(i,j)的路径条数,但是对于边界需要特殊的处理也就是他们只能一条方向移动也就是他们的初始化结果为1：所以代码实现如下所示</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>		<span class="hljs-type">int</span> [][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>		<span class="hljs-comment">//动态规划首先将边界上的值都定为1因为他们只能从一个方向移动</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//根据dp[i][j]它可以是从dp[i-1][j]来的也可以是dp[i][j-1]来的</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++){<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++){<br>				dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];<br>			}<br>		}<br>		<span class="hljs-comment">//只需要考虑它的来源就行了</span><br>		<span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>96.给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151030746.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 3<br>输出：5<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：n = 1<br>输出：1<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<p><strong>思路题解：</strong></p>
<p>纯纯的数学问题，如果理解了这个数学原理这个小题还是手到擒来<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 你这样来看一下我先去偷几张图片</p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151034600.png" alt="image-20230315103427506"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151035388.png" alt="image-20230315103510335"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151035345.png" alt="image-20230315103523291"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151035946.png" alt="image-20230315103535885"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151035135.png" alt="image-20230315103549071"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151036372.png" alt="image-20230315103602307"></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303151036259.png" alt="image-20230315103612193"></p>
<p>看懂了吗？大概就是当你以某个值为根节点的时候就需要分成两部分右子树(i-1)和左子树(n-i)那么总的情况就是两者相乘，<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后好玩的来了，对于右子树是不是还可以继续向下递归，左子树同理，然后就把自己给递归死了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不要着急,递归总有个头，头是什么呢？当然是n=1和n=0呀他们两个的结果都为1，所以一切的变得好起来了</p>
<p>还有值得提一嘴的是：二叉树的左子树数值小于右子树，也就是中序遍历的是有序的！！</p>
<p>所以代码思想就是：首先规定递归的结束就是n=1||n=0返回1,<span class="github-emoji"><span>😸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f638.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 而且给一个总的count来记录当前的值开始从i=1开始让每一个数字都当一次根节点，并且每次都记录其左子树和右子树的种类，并且将其相乘的结果与count累加；但是后来你会发现一个严重的问题就是，大量的重复递归<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>怎么解决呢，首先想到的是每次每个根节点对应的count值是相同的，那我们把他记录下来，当下次需要的时候直接查询就好了!!<span class="github-emoji"><span>🚚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f69a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>简单一个map容器就实现了这个逻辑,全局构建一个map容器,将每次递归的结果放入map（n,count）然后在每次递归的前面进行判断，当前容器是否还有n的count值有的话直接就return就行了，省的接着递归<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>代码如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>		Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-comment">// 1 2 5 14 42</span><br>		<span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>||n==<span class="hljs-number">0</span>){<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		}<br>        <span class="hljs-comment">//判断当前的容器是否有n对应的count值有的话直接return没有在递归遍历</span><br>		<span class="hljs-keyword">if</span> (map.containsKey(n)){<br>			<span class="hljs-keyword">return</span> map.get(n);<br>		}<br>		<span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){<br>			<span class="hljs-type">int</span> leftNum=numTrees(i-<span class="hljs-number">1</span>);<br>			<span class="hljs-type">int</span> rightNum=numTrees(n-i);<br>			count+=leftNum*rightNum;<br>		}<br>        <span class="hljs-comment">//将每次的n递归的结果进行保存</span><br>		map.put(n,count);<br>		<span class="hljs-keyword">return</span> count;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>114.给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303152012442.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = []<br>输出：[]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [0]<br>输出：[0]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>题目解析：</strong></p>
<p>本道题很简单的思路：<strong>回炉重造!!</strong><span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>很简单吧，前序遍历你会把，构造一个新的树你也会把，然后一切都简单了哈哈哈 <span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>简单的遍历将所有的节点存储起来，然后再对储存的节点进行遍历每次遍历都让其左子树为null下一个指向右子树:就这麽简单 代码实现如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> {<br>		List&lt;TreeNode&gt;list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>		creatTree(root,list);<br>		<span class="hljs-type">int</span> size=list.size();<br>        <span class="hljs-comment">//对集合进行重新的构造 easy</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++){<br>			TreeNode prev=list.get(i-<span class="hljs-number">1</span>),curr=list.get(i);<br>			prev.left=<span class="hljs-literal">null</span>;<br>			prev.right=curr;<br>		}<br><br>    }<br>    <span class="hljs-comment">//得到节点的集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creatTree</span><span class="hljs-params">(TreeNode root,List&lt;TreeNode&gt; list)</span>{<br>    	<span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>){<br>    		list.add(root);<br>    		creatTree(root.left,list);<br>    		creatTree(root.right,list);<br>		}<br><br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>148.给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303160917576.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：head = [4,2,1,3]<br>输出：[1,2,3,4]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303160917579.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：head = [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：head = []<br>输出：[]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>思路解析：</strong></p>
<p>看到这道题进行排序一个大胆而又简单的方法浮现再脑中首先对收集所有的元素<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>到一个数组中，然后排序，最后构造新的链表<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（这个方法切实可行都搞出来了）就是时间复杂度和空间复杂度有些高，不会吧不会这样搞吧！当然不是了<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 进入正题,我们看到排序这道题而且又要快速的进行，首先想到的不二法门就是归并排序:很方便的如下图:</p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303160928100.png" alt="image-20230316092841019"></p>
<p>通过递归实现归并排序主要包含两个步骤：</p>
<ul>
<li><strong>分割cut环节</strong>：就是找到链表的中点，然后进行切开，一个可行的方案就是快慢指针,一个每次走一下，一个走两下是不是他们之间的差距就是二倍<span class="github-emoji"><span>😼</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>,当我们找到中点的时候要干嘛，当然是切开链表了!笨!,切开后就分开进行递归操作，将两条链表的头节点传入递归函数中，当然要递归肯定要考虑递归的终止条件呀，想想，当递归到最后发现什么<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>是不是只有一个节点了也就是头,所以结束的条件很简单head.next=null说明递归结束啦!!</li>
<li><strong>合并merge环节</strong> ：将两个排序后的链表进行合并，转化为一个链表</li>
</ul>
<p>这步操作就有些想头了<span class="github-emoji"><span>😹</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f639.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>因为需要两条链表的合并，并不是那么号操作，所以综合考虑就进行一个很常见的操作也就是双指针合并发，需要一个辅助指针h作为头部进行合并操作。</p>
<p>具体方法就是设置两个指针分别指向两链表的头部，比较两指针处节点值得大小，有小到大加入合并链表头部，指针交替前进，直至添加完成两个链表就行啦,是不是很好理解<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>其实这里不需要进行新节点的创建，咱们只需要改变指针的指向就ok了在一个新的链表上面，让他疯狂的指来指去,当然当合并完成后，可还没有结束考虑一种当左链表比较短，当逐渐的加入后左链表元素用完了怎么办？这里需要一个很好的解决方法:哈哈哈左边完了，直接将右边的全部拼接上来不久行了慢，直接一条道走向成功：代码实现如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> {<br>        <span class="hljs-comment">//结束的条件也就是头节点为空（防止空链表）或者只剩下一个节点</span><br>		<span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>){<br>			<span class="hljs-keyword">return</span> head;<br>		}<br>        <span class="hljs-comment">//快慢指针找到中间的值</span><br>		ListNode fast=head.next,slow=head;<br>		<span class="hljs-keyword">while</span> (fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>){<br>			slow=slow.next;<br>			fast=fast.next.next;<br>		}<br>        <span class="hljs-comment">//因为慢指针会慢一步，所以需要一个临时节点存储第二条链表的头部</span><br>		ListNode tmp=slow.next;<br>        <span class="hljs-comment">//断开链表</span><br>		slow.next=<span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//对左链表进行递归</span><br>		ListNode left=sortList(head);<br>        <span class="hljs-comment">//对右链表进行递归</span><br>		ListNode right=sortList(tmp);<br>        <span class="hljs-comment">//一个储存结果的链表</span><br>		ListNode h=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>		ListNode res=h;<br>        <span class="hljs-comment">//加入链表的结束条件就是两个链表都不为null</span><br>		<span class="hljs-keyword">while</span> (left!=<span class="hljs-literal">null</span>&amp;&amp;right!=<span class="hljs-literal">null</span>){<br>			<span class="hljs-keyword">if</span> (left.val&lt;right.val){<br>				h.next=left;<br>				left=left.next;<br>			}<span class="hljs-keyword">else</span> {<br>				h.next=right;<br>				right=right.next;<br>			}<br>			h=h.next;<br>		}<br>        <span class="hljs-comment">//当出现左链表都空的话直接把右链表全部搬过来:完！</span><br>		h.next=left!=<span class="hljs-literal">null</span>?left:right;<br>		<span class="hljs-keyword">return</span> res.next;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>152.给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>子数组</strong> 是数组的连续子序列。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>想都不用想一看就是动态规划的思想，不过这里有个比较有意思的情况，就是需要考虑复数的情况，每次记录的乘积结果根据下一个值得不同而进行动态改变 <span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后我们需要将max和min一起作为代表，才能很好得结果这道题目，fmax[i]、fin[i]表示以i结尾得最大，最小乘积得数组,一切都变得好理解了，直接打表，对每一个以i结尾得数组进行相应得操作，咱们不需要考虑是否截取了某一段，反正最后得结果只是需要某一段的乘积最大值<span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>所以呢就可以得到很好的状态转移方程式:<br><code>fmax[i] = max{fmax[i-1]*nums[i], fmin[i-1]*nums[i],nums[i]}</code></p>
<p><code>fmin[i] = min{fmax[i-1]*nums[i], fmin[i-1]*nums[i],nums[i]}</code></p>
<p>根据以上的式子就可以求出每个以i结尾的子项的最大最小值</p>
<p>最后一个遍历循环找出fmax中的最大值就可以了<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>    	<span class="hljs-type">int</span> n=nums.length;<br>    	<span class="hljs-type">int</span>[]fmax=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    	<span class="hljs-type">int</span>[]fmin=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    	fmin[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>    	fmax[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//这个需要好好的思考一下，很好的存储了当前i之前的最大最小值，而且有一点就是它是原数组的子集是能连续起来的!</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++){<br>    		fmax[i]=Math.max(Math.max(nums[i]*fmax[i-<span class="hljs-number">1</span>],nums[i]*fmin[i-<span class="hljs-number">1</span>]),nums[i]);<br>    		fmin[i]=Math.min(Math.min(nums[i]*fmax[i-<span class="hljs-number">1</span>],nums[i]*fmin[i-<span class="hljs-number">1</span>]),nums[i]);<br>		}<br>    	<span class="hljs-type">int</span> ans=fmax[<span class="hljs-number">0</span>];<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){<br>    		ans=Math.max(ans,fmax[i]);<br>		}<br>    	<span class="hljs-keyword">return</span> ans;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>方法二：更好理解</strong></p>
<p>该题明显就是一个动态规划问题：从小偷的角度出发，每次当他到达一个地点无非两种选择，要么偷要么不偷<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>而且有意思的是为了保证最后的金额最大，每次偷取相邻的三个之内必定要有一个被偷，所以这里记录一个f【i】表示前i个能偷的最大金额，首先就是初始化将f【0】和f【1】进行初始化后，直接对nums进行遍历，当遍历到一个数的时候两种情况，偷的话就是nums[i]+f[n-2]，不偷的话就是f[i-1]去两者的最大值就行了代码实现如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>		<span class="hljs-comment">//一个动态规划的题目</span><br>		<span class="hljs-type">int</span> n=nums.length;<br>		<span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>){<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		}<br>		<span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>){<br>			<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>		}<br>		<span class="hljs-type">int</span>[]f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>		f[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>		f[<span class="hljs-number">1</span>]=Math.max(nums[<span class="hljs-number">1</span>],nums[<span class="hljs-number">0</span>]);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++){<br>			f[i]=Math.max(nums[i]+f[i-<span class="hljs-number">2</span>],f[i-<span class="hljs-number">1</span>]);<br>		}<br>		<span class="hljs-keyword">return</span> f[n-<span class="hljs-number">1</span>];<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>207.你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：numCourses = 2, prerequisites = [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]<br>输出：false<br>解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 105</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路:</strong></p>
<p>做这道题一开始没什么思路，想法是有的就是优点难以实现<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>第一个想法就是我能不能构造一个链表<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后再利用快慢指针，因为如果不符合题意得要求肯定是存在环路，咱只需要快指针能追得上满指针就行了，然后仔细一想，不对呀！<span class="github-emoji"><span>😹</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f639.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>这个链表不止有一条，有许多条，这个肯定行不通，然后就思索第二条出路,这部参考一下，nice竟然使用了图的方法构造一个入度表，每次让入度为零的点出栈，对别的点进行消边，如果别的点的入度为零继续入栈，然后出栈，等等等有些迷瞪了？看图说话<span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031159.png" alt="207-1.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031176.png" alt="207-2.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031412.png" alt="207-3.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031101.png" alt="207-4.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031270.png" alt="207-5.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031105.png" alt="207-6.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031710.png" alt="207-7.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031688.png" alt="207-8.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031752.png" alt="207-9.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031698.png" alt="207-10.png">,<img src="https://pic.leetcode-cn.com/e91ef7c5d01de19f3ef7126e3503430867f897d01f81b7a7607dd551a8743786-207-11.png" alt="207-11.png">,<img src="https://pic.leetcode-cn.com/7fcc5454f1562a1b231aa1fba29bd023c719730257776a10a64c5f5282660fb8-207-12.png" alt="207-12.png">,<img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303172031516.png" alt="207-13.png"></p>
<p>对对对就是这个思路，咱就一个一个点的删除当删除到最后看看是不是将原本传入的numCourses置位0了如果成功，恭喜你：一切都成功了，下面看代码说话，这个程序代码优点绕，奶奶的确实绕!看看理解理解吧</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>      <span class="hljs-comment">//[[3, 0], [3, 1], [4, 1], [4, 2], [5, 3], [5, 4]]一个能完成的例子</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> {<br>           <span class="hljs-comment">//初始化入度的点集合都让他的入度为0</span><br>           <span class="hljs-type">int</span>[] RuDu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>           <span class="hljs-comment">//建立一个点的集合，这个用来存放（B---&gt;A）中的A，因为对于B来说学习完成后可以学习多个A</span><br>           List&lt;List&lt;Integer&gt;&gt; DianJi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           <span class="hljs-comment">//这个是初始化队列主要用于存放那些入度为0的课程号，以便后来的逐个进行去除如上图所示</span><br>           Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>           <span class="hljs-comment">//这个就有意思了因为我们之前构造了一个Dianji这里我们要吧它的大小扩充到numCourse哈哈这里是为了使用它的下标来表明是那个课程</span><br>           <span class="hljs-comment">//然后再对应的课程下面存放了一些他需要修行的先行课也就是下标代表B,里面的list集合代表A</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) {<br>               DianJi.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>           }<br>           <span class="hljs-comment">//这个就是开始进行一个RuDu的初始化以及，对修课程B所需要的课程A进行构造</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] cp : prerequisites) {<br>               <span class="hljs-comment">//有数据的结构如[A,B]==&gt; B---&gt;A也就是A的优先级要高B更次级所以这里的入度就是cp[0]</span><br>               RuDu[cp[<span class="hljs-number">0</span>]]++;<br>               <span class="hljs-comment">//这个好好思虑一波这个意思就是再课程B的下标出添加他修完后能继续修习A课程的集合</span><br>               <span class="hljs-comment">//先将相同的B对应A的集合存入，然后在队列中找到一个课程B并取出集合A的元素，有这个元素可以对应到入度数组进行--操作</span><br>               DianJi.get(cp[<span class="hljs-number">1</span>]).add(cp[<span class="hljs-number">0</span>]);<br>           }<br>           <span class="hljs-comment">//第一次首先将入度为0的给记录入栈</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) {<br>               <span class="hljs-keyword">if</span> (RuDu[i] == <span class="hljs-number">0</span>) queue.add(i);<br>           }<br>           <span class="hljs-comment">//当栈不为空就循环</span><br>           <span class="hljs-keyword">while</span> (!queue.isEmpty()) {<br>               <span class="hljs-comment">//先取出度数为0的课程也就是一个课程点出栈</span><br>               <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> queue.poll();<br>               numCourses--;<br>               <span class="hljs-comment">//在DianJi中找到对应的A集合中的元素，如果在RuDu的集合中不为0就进行--操作，当减到为0就入栈</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur : DianJi.get(pre))<br>                   <span class="hljs-keyword">if</span> (--RuDu[cur] == <span class="hljs-number">0</span>) queue.add(cur);<br>           }<br>           <span class="hljs-comment">//对结果进行一个判断</span><br>           <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;<br>       }<br>   }<br></code></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://7756jokerqaq.github.io">LiYiChen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://7756jokerqaq.github.io/2022/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/Leecode%E5%88%B7%E9%A2%98/">https://7756jokerqaq.github.io/2022/03/11/数据结构算法学习/Leecode刷题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://7756jokerqaq.github.io" target="_blank">JokerQAQ的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8A%9B%E6%89%A3/">力扣</a></div><div class="post_share"><div class="social-share" data-image="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/08/27/%E4%BB%A3%E7%A0%81%E5%BF%AB%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"><img class="prev-cover" src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/computer.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">笔记模板</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/Leecode%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="LeeCode"><img class="cover" src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/asd123324.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">LeeCode</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/wallhaven-4y6170_1920x1080.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LiYiChen</div><div class="author-info__description">日常学习记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/7756JokerQAQ"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/7756JokerQAQ" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2677006173@qq.com" target="_blank" title="QQ邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://7756jokerqaq.github.io" target="_blank" title="博客"><i class="fa-brands fa-blogger"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">日常学习java后端和前端</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Leecode%E5%88%B7%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Leecode刷题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/05/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/SpringSecurity/" title="无题"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/3481/wallhaven-m93px9_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/04/05/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/SpringSecurity/" title="无题">无题</a><time datetime="2023-04-05T12:28:31.104Z" title="发表于 2023-04-05 20:28:31">2023-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%8D%95%E8%B0%83%E6%A0%88and%E4%BA%8C%E5%8F%89%E6%A0%91/" title="单调栈和二叉树"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303211444122.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单调栈和二叉树"/></a><div class="content"><a class="title" href="/2023/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%8D%95%E8%B0%83%E6%A0%88and%E4%BA%8C%E5%8F%89%E6%A0%91/" title="单调栈和二叉树">单调栈和二叉树</a><time datetime="2023-03-20T16:00:00.000Z" title="发表于 2023-03-21 00:00:00">2023-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Eureka%E5%92%8CRibbon/" title="Eureka And Ribbon"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Eureka And Ribbon"/></a><div class="content"><a class="title" href="/2023/03/19/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Eureka%E5%92%8CRibbon/" title="Eureka And Ribbon">Eureka And Ribbon</a><time datetime="2023-03-18T16:00:00.000Z" title="发表于 2023-03-19 00:00:00">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Nacos/" title="Nacos"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nacos"/></a><div class="content"><a class="title" href="/2023/03/19/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Nacos/" title="Nacos">Nacos</a><time datetime="2023-03-18T16:00:00.000Z" title="发表于 2023-03-19 00:00:00">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/" title="面试题2"><img src="https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191547821.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题2"/></a><div class="content"><a class="title" href="/2023/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%982/" title="面试题2">面试题2</a><time datetime="2023-03-18T16:00:00.000Z" title="发表于 2023-03-19 00:00:00">2023-03-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://joker-qaq1-1314468534.cos.ap-beijing.myqcloud.com/learn/202303191548952.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By LiYiChen</div><div class="footer_custom_text">Hi,welcome to my <a href="https://7756jokerqaq.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="ftrue"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>